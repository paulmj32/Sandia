### Data from ACS-5yr
acs_vars_use = c("B01001B_001", "B01001A_001", "B01003_001")
acs_data = get_acs(geography = "tract", state = state, county = county,
variables=acs_vars_use, year = year, geometry = FALSE)
df = county_map %>%
left_join(acs_data_w, by = "GEOID") %>% #join ACS_5yr data
mutate(QBLACK = B01001B_001 / B01003_001) %>%
mutate(QWHITE = B01001A_001 / B01003_001) %>%
dplyr::select(QWHITE, QBLACK)
#long to wide format
acs_data_w = acs_data %>%
select(-moe, -NAME) %>% #remove errors of estimates because we're spreading by variable and don't want duplicates, and don't need name b/c joining by GEOID
spread(key=variable, value = estimate)
white = df %>%
ggplot(aes(fill = QWHITE)) +
geom_sf(color = NA) +
scale_fill_viridis_c(option = "magma")
year=2018
### Geometry base - US Counties
options(tigris_use_cache = TRUE) #to cache shapefiles for future sessions
state = "Georgia"
county = c("Cherokee", "Cobb")
county_map = get_acs(geography = "tract", state = state, county = county,
variables=c("B01003_001"), year = year, geometry = TRUE,
cache_table = TRUE)
county_map = county_map %>% select(GEOID, NAME)
### Data from ACS-5yr
acs_vars_use = c("B01001B_001", "B01001A_001", "B01003_001")
acs_data = get_acs(geography = "tract", state = state, county = county,
variables=acs_vars_use, year = year, geometry = FALSE)
#long to wide format
acs_data_w = acs_data %>%
select(-moe, -NAME) %>% #remove errors of estimates because we're spreading by variable and don't want duplicates, and don't need name b/c joining by GEOID
spread(key=variable, value = estimate)
df = county_map %>%
left_join(acs_data_w, by = "GEOID") %>% #join ACS_5yr data
mutate(QBLACK = B01001B_001 / B01003_001) %>%
mutate(QWHITE = B01001A_001 / B01003_001) %>%
dplyr::select(QWHITE, QBLACK)
white = df %>%
ggplot(aes(fill = QWHITE)) +
geom_sf(color = NA) +
scale_fill_viridis_c(option = "magma")
mapview(df, zcol = c("QWHITE"), legend = TRUE, alpha.regions = 0.32)
(1.05)^44
10498202 - 3121272
load("~/Documents/01_VECTOR/HUD_cateslanding/inland waterway code R/data/CatesLanding_data2.RData")
asd = 1:20
plot(1.1^asd)
asd = 1:50
plot(1.1^asd)
asd = 1:30
plot(1.1^asd)
asd = 1:20
plot(1.1^asd)
1.1^asd
library(tidycensus) #api with census
library(sf) #class and functions for vector data
library(tidyverse) #collection of r data tools, including dplyr
library(mapview)
year=2018
### Geometry base - US Counties
options(tigris_use_cache = TRUE) #to cache shapefiles for future sessions
state = "Georgia"
county = c("Cherokee", "Cobb")
county_map = get_acs(geography = "tract", state = state, county = county,
variables=c("B01003_001"), year = year, geometry = TRUE,
cache_table = TRUE)
county_map = county_map %>% select(GEOID, NAME)
### Data from ACS-5yr
acs_vars_use = c("B01001B_001", "B01001A_001", "B01003_001")
acs_data = get_acs(geography = "tract", state = state, county = county,
variables=acs_vars_use, year = year, geometry = FALSE)
#long to wide format
acs_data_w = acs_data %>%
select(-moe, -NAME) %>% #remove errors of estimates because we're spreading by variable and don't want duplicates, and don't need name b/c joining by GEOID
spread(key=variable, value = estimate)
df = county_map %>%
left_join(acs_data_w, by = "GEOID") %>% #join ACS_5yr data
mutate(QBLACK = B01001B_001 / B01003_001) %>%
mutate(QWHITE = B01001A_001 / B01003_001) %>%
dplyr::select(QWHITE, QBLACK)
white = df %>%
ggplot(aes(fill = QWHITE)) +
geom_sf(color = NA) +
scale_fill_viridis_c(option = "magma")
mapview(df, zcol = c("QWHITE"), legend = TRUE, alpha.regions = 0.32)
mapview(df, zcol = c("QBLACK"), legend = TRUE, alpha.regions = 0.32)
### Subdivision
state = "Georgia"
county = c("Cherokee", "Cobb")
sub_map = get_acs(geography = "county subdivision", state = state, county = county,
variables=c("B01003_001"), year = year, geometry = TRUE,
cache_table = TRUE)
sub_map = sub_map %>% select(GEOID, NAME)
### Subdivision
sub_map = get_acs(geography = "county subdivision", state = state, county = county,
variables=c("B01003_001"), year = year, geometry = TRUE,
cache_table = TRUE)
sub_map = sub_map %>% select(GEOID, NAME)
acs_sub = get_acs(geography = "county subdivision", state = state, county = county,
variables=acs_vars_use, year = year, geometry = FALSE)
acs_sub_w = acs_sub %>%
select(-moe, -NAME) %>% #remove errors of estimates because we're spreading by variable and don't want duplicates, and don't need name b/c joining by GEOID
spread(key=variable, value = estimate)
df_sub = sub_map %>%
left_join(acs_data_w, by = "GEOID") %>% #join ACS_5yr data
mutate(QBLACK = B01001B_001 / B01003_001) %>%
mutate(QWHITE = B01001A_001 / B01003_001) %>%
dplyr::select(QWHITE, QBLACK)
mapview(df_sub, zcol = c("QBLACK"), legend = TRUE, alpha.regions = 0.32)
df_sub
acs_sub_w
sub_map
df_sub
View(df_sub)
### Subdivision
sub_map = get_acs(geography = "block group", state = state, county = county,
variables=c("B01003_001"), year = year, geometry = TRUE,
cache_table = TRUE)
sub_map = sub_map %>% select(GEOID, NAME)
acs_sub_w = acs_sub %>%
select(-moe, -NAME) %>% #remove errors of estimates because we're spreading by variable and don't want duplicates, and don't need name b/c joining by GEOID
spread(key=variable, value = estimate)
mapview(df_sub, zcol = c("QBLACK"), legend = TRUE, alpha.regions = 0.32)
acs_sub = get_acs(geography = "block group", state = state, county = county,
variables=acs_vars_use, year = year, geometry = FALSE)
df_sub = sub_map %>%
left_join(acs_data_w, by = "GEOID") %>% #join ACS_5yr data
mutate(QBLACK = B01001B_001 / B01003_001) %>%
mutate(QWHITE = B01001A_001 / B01003_001) %>%
dplyr::select(QWHITE, QBLACK)
df_sub
v18 = load_variables(2018, "acs5", cache = TRUE)
View(v18)
mapview(df, zcol = c("QBLACK"), legend = TRUE, alpha.regions = 0.32)
library(tidycensus) #api with census
library(sf) #class and functions for vector data
library(tidyverse) #collection of r data tools, including dplyr
library(mapview)
year=2018
state = "Alabama"
county = c("Madison")
county_map = county_map %>% select(GEOID, NAME)
acs_data = get_acs(geography = "tract", state = state, county = county,
variables=acs_vars_use, year = year, geometry = FALSE)
### Geometry base - US Counties
options(tigris_use_cache = TRUE) #to cache shapefiles for future sessions
county_map = get_acs(geography = "tract", state = state, county = county,
variables=c("B01003_001"), year = year, geometry = TRUE,
cache_table = TRUE)
### Data from ACS-5yr
acs_vars_use = c("B01001B_001", "B01001A_001", "B01003_001")
df = county_map %>%
left_join(acs_data_w, by = "GEOID") %>% #join ACS_5yr data
mutate(QBLACK = B01001B_001 / B01003_001) %>%
mutate(QWHITE = B01001A_001 / B01003_001) %>%
dplyr::select(QWHITE, QBLACK)
#long to wide format
acs_data_w = acs_data %>%
select(-moe, -NAME) %>% #remove errors of estimates because we're spreading by variable and don't want duplicates, and don't need name b/c joining by GEOID
spread(key=variable, value = estimate)
#long to wide format
acs_data_w = acs_data %>%
select(-moe, -NAME) %>% #remove errors of estimates because we're spreading by variable and don't want duplicates, and don't need name b/c joining by GEOID
spread(key=variable, value = estimate)
acs_data = get_acs(geography = "tract", state = state, county = county,
variables=acs_vars_use, year = year, geometry = FALSE)
#long to wide format
acs_data_w = acs_data %>%
select(-moe, -NAME) %>% #remove errors of estimates because we're spreading by variable and don't want duplicates, and don't need name b/c joining by GEOID
spread(key=variable, value = estimate)
df = county_map %>%
left_join(acs_data_w, by = "GEOID") %>% #join ACS_5yr data
mutate(QBLACK = B01001B_001 / B01003_001) %>%
mutate(QWHITE = B01001A_001 / B01003_001) %>%
dplyr::select(QWHITE, QBLACK)
mapview(df, zcol = c("QBLACK"), legend = TRUE, alpha.regions = 0.32)
# LIST OF VARIABLES
v18 = load_variables(2018, "acs5", cache = TRUE)
View(v18)
library(tidyverse)
library(readxl)
library(sf)
library(tidycensus)
library(tidycensus) #api with census
library(sf) #class and functions for vector data
library(tidyverse) #collection of r data tools, including dplyr
library(mapview)
year=2018
### Geometry base - US Counties
options(tigris_use_cache = TRUE) #to cache shapefiles for future sessions
state = "Texas"
county = c("Harris")
county_map = get_acs(geography = "tract", state = state, county = county,
variables=c("B01003_001"), year = year, geometry = TRUE,
cache_table = TRUE)
county = c("Harris County")
county_map = get_acs(geography = "tract", state = state, county = county,
variables=c("B01003_001"), year = year, geometry = TRUE,
cache_table = TRUE)
View(county_map)
county_map = county_map %>% select(GEOID, NAME)
### Data from ACS-5yr
acs_vars_use = c("B01001B_001", "B01001A_001", "B01003_001")
acs_data = get_acs(geography = "tract", state = state, county = county,
variables=acs_vars_use, year = year, geometry = FALSE)
#long to wide format
acs_data_w = acs_data %>%
select(-moe, -NAME) %>% #remove errors of estimates because we're spreading by variable and don't want duplicates, and don't need name b/c joining by GEOID
spread(key=variable, value = estimate)
df = county_map %>%
left_join(acs_data_w, by = "GEOID") %>% #join ACS_5yr data
mutate(QBLACK = B01001B_001 / B01003_001) %>%
mutate(QWHITE = B01001A_001 / B01003_001) %>%
dplyr::select(QWHITE, QBLACK)
white = df %>%
ggplot(aes(fill = QWHITE)) +
geom_sf(color = NA) +
scale_fill_viridis_c(option = "magma")
plot(white)
View(county_map)
write.csv(county_map, "/Users/paulmj/Documents/01_VECTOR/UH_CIVIC/Harris_census_2018.csv", row.names = TRUE)
county_map2 = county_map %>%
st_geometry(NULL)
county_map2 = county_map %>%
st_set_geometry(NULL)
write.csv(county_map2, "/Users/paulmj/Documents/01_VECTOR/UH_CIVIC/Harris_census_2018.csv", row.names = TRUE)
year=2019
### Geometry base - US Counties
options(tigris_use_cache = TRUE) #to cache shapefiles for future sessions
state = "Texas"
county = c("Harris County")
county_map = get_acs(geography = "tract", state = state, county = county,
variables=c("B01003_001"), year = year, geometry = TRUE,
cache_table = TRUE)
county_map = county_map %>% select(GEOID, NAME)
### Data from ACS-5yr
acs_vars_use = c("B01001B_001", "B01001A_001", "B01003_001")
acs_data = get_acs(geography = "tract", state = state, county = county,
variables=acs_vars_use, year = year, geometry = FALSE)
#long to wide format
acs_data_w = acs_data %>%
select(-moe, -NAME) %>% #remove errors of estimates because we're spreading by variable and don't want duplicates, and don't need name b/c joining by GEOID
spread(key=variable, value = estimate)
df = county_map %>%
left_join(acs_data_w, by = "GEOID") %>% #join ACS_5yr data
mutate(QBLACK = B01001B_001 / B01003_001) %>%
mutate(QWHITE = B01001A_001 / B01003_001) %>%
dplyr::select(QWHITE, QBLACK)
white = df %>%
ggplot(aes(fill = QWHITE)) +
geom_sf(color = NA) +
scale_fill_viridis_c(option = "magma")
black = df %>%
ggplot(aes(fill = QBLACK)) +
geom_sf(color = NA) +
scale_fill_viridis_c(option = "magma")
county_map2 = county_map %>%
st_set_geometry(NULL)
write.csv(county_map2, "/Users/paulmj/Documents/01_VECTOR/UH_CIVIC/Harris_censustract_2019acs.csv", row.names = TRUE)
year=2020
### Geometry base - US Counties
options(tigris_use_cache = TRUE) #to cache shapefiles for future sessions
state = "Texas"
county = c("Harris County")
county_map = get_acs(geography = "tract", state = state, county = county,
variables=c("B01003_001"), year = year, geometry = TRUE,
cache_table = TRUE)
?get_acs
county_map = get_acs(geography = "tract", state = state, county = county,
variables=c("B01003_001"), year = 2020, geometry = TRUE,
cache_table = TRUE, survey = "acs1")
county_map = get_acs(geography = "tract", state = state, county = county,
variables=c("B01003_001"), year = 2019, geometry = TRUE,
cache_table = TRUE, survey = "acs1")
county_map = get_acs(geography = "tract", state = state, county = county,
variables=c("B01003_001"), year = 2019, geometry = TRUE,
cache_table = TRUE, survey = "acs5")
county_map = get_acs(geography = "tract", state = state, county = county,
variables=c("B01003_001"), year = 2019, geometry = TRUE,
cache_table = TRUE, survey = "acs1")
county_map = get_acs(geography = "tract", state = state, county = county,
variables=c("B01003_001"), year = 2020, geometry = TRUE,
cache_table = TRUE, survey = "acs1")
county_map = get_acs(geography = "tract", state = state, county = county,
variables=c("B01003_001"), year = 2021, geometry = TRUE,
cache_table = TRUE, survey = "acs1")
county_map = get_acs(geography = "tract", state = state, county = county,
variables=c("B01003_001"), year = 2019, geometry = TRUE,
cache_table = TRUE, survey = "acs1")
county_map = county_map %>% select(GEOID, NAME)
install.packages("stars")
library(tidyverse)
library(tidycensus)
library(sf)
library(terra)
library(stars)
load("~/Documents/01_VECTOR.nosync/Sandia/TX_group.Rda")
## Root zone data
TX_gdb =  "/Users/paulmj/Downloads/gSSURGO_TX/gSSURGO_TX.gdb"
TX_Valu1 = sf::st_read(dsn = TX_gdb, layer = "Valu1")
TX_group_val1 = TX_group %>% left_join(TX_Valu1, by = c("MUKEY" = "mukey"))
TX_group_val1_100 = TX_group_val1 %>%
filter(!is.na(rootznemc)) %>%
slice(1:100) %>%
select(MUKEY, rootznemc)
?st_rasterize
TX_rast100 = st_rasterize(TX_group_val1_100)
TX_rast100 = st_rasterize(TX_group_val1_100["rootznemc"])
plot(TX_rast100)
TX_rast = st_rasterize(TX_group_val1["rootznemc"])
plot(TX_rast)
rr = ggplot() +
geom_tile(data = TX_rast, aes(x = x, y = y, fill = rootznemc)) +
scale_fill_viridis_c()
rr = ggplot() +
geom_stars(data = TX_rast, aes(x = x, y = y, fill = rootznemc)) +
scale_fill_viridis_c()
rr
rr = ggplot() +
geom_stars(data = TX_rast, aes(x = x, y = y, fill = rootznemc)) +
scale_fill_viridis_c(direction = -1)
rr
rr = ggplot() +
#geom_stars(data = TX_rast, aes(x = x, y = y, fill = rootznemc)) +
geom_stars(data = TX_rast, aes(fill = rootznemc)) +
scale_fill_viridis_c(direction = -1)
rr
rr = ggplot() +
geom_stars(data = TX_rast, aes(x = x, y = y, fill = rootznemc)) +
scale_fill_viridis_c(direction = -1)
rr
rr = ggplot() +
geom_stars(data = TX_rast, aes(x = x, y = y, fill = rootznemc), alpha = 0.8) +
scale_fill_viridis_c(direction = -1)
rr
rr = ggplot() +
geom_stars(data = TX_rast, aes(x = x, y = y, fill = rootznemc), alpha = 0.9) +
scale_fill_viridis_c(direction = -1)
rr
rr = ggplot() +
geom_stars(data = TX_rast, aes(x = x, y = y, fill = rootznemc)) +
scale_fill_viridis_c(direction = -1)
rr
rr = ggplot() +
geom_stars(data = TX_rast, aes(x = x, y = y, fill = rootznemc)) +
scale_fill_viridis_c(direction = -1) +
theme_bw()
rr
rr = ggplot() +
geom_stars(data = TX_rast, aes(x = x, y = y, fill = rootznemc)) +
scale_fill_viridis_c(direction = -1) +
theme_classic()
rr
rr = ggplot() +
geom_stars(data = TX_rast, aes(x = x, y = y, fill = rootznemc)) +
scale_fill_viridis_c(direction = -1) +
theme_minimal()
rr
rr = ggplot() +
geom_stars(data = TX_rast, aes(x = x, y = y, fill = rootznemc)) +
scale_fill_viridis_c(direction = -1)
rr
rr = ggplot() +
geom_stars(data = TX_rast, aes(x = x, y = y, fill = rootznemc)) +
scale_fill_viridis_c(direction = -1, na.value = "white")
rr
rr = ggplot() +
geom_stars(data = TX_rast, aes(x = x, y = y, fill = rootznemc)) +
scale_fill_viridis_c(direction = -1, na.value = "gray")
rr
rr = ggplot() +
geom_stars(data = TX_rast, aes(x = x, y = y, fill = rootznemc)) +
scale_fill_viridis_c(direction = -1, na.value = "gray") +
theme_light()
rr
rr = ggplot() +
geom_stars(data = TX_rast, aes(x = x, y = y, fill = rootznemc)) +
scale_fill_viridis_c(direction = -1, na.value = "gray") +
theme_minimal()
rr
st_crs(TX_rast)
st_crs(TX_rast)$units_gdal
TX_rast_1k = st_rasterize(TX_group_val1["rootznemc"], dx = 1000, dy = 1000)
rr = ggplot() +
geom_stars(data = TX_rast_1k, aes(x = x, y = y, fill = rootznemc)) +
scale_fill_viridis_c(direction = -1, na.value = "gray") +
theme_minimal()
rr
install.packages("sqldf")
version
install.packages("sqldf")
install.packages("hurricaneexposure")
options(java.parameters = "-Xmx6g")
library(bartMachine)
set_bart_machine_num_cores(4)
library(lme4)
library(tidyverse)
library(tidycensus)
library(sf)
library(terra)
library(stars)
library(sqldf)
setwd("~/Documents/01_VECTOR.nosync/Sandia")
mycrs = 5070
load(file = "./Data/county_map_group_join.Rda")
## restrict to only big outages (80 percentile)
df_bart = data.frame(county_map_group_join) %>%
drop_na %>%
dplyr::filter(customers_out_perc < 1) %>% #remove bad data
dplyr::filter(hours > quantile(county_map_group_join$hours, .9)) %>%
mutate(customer_out_hrs = customers_out / 1000 * hours) #Kilo customer_out_hrs
summary(df_bart$hours)
log(12)
y1 = log(df_bart$hours)
X = df_bart %>%
dplyr::select(-outage_number, -GEOID, -customers_out_perc, -customer_out_hrs, -hours)
set.seed(32)
bartY1 = bartMachine(X, y1)
bart = bartY1
Y = y1
bart = bartY1
Y = y1
varimp = investigate_var_importance(bart, num_replicates_for_avg = 5)
predictions = predict(bart, X)
CI = round(calc_credible_intervals(bart, X, ci_conf = 0.95), 2)
gg = dplyr::tibble(x_mean = predictions,
lower = CI[,1],
upper = CI[,2],
actual = Y
)
gg = arrange(gg, actual)
gg$index = seq.int(nrow(gg))
plot_filtering_estimates <- function(df) {
p <- ggplot(data = gg, aes(x = index)) +
theme_classic() +
geom_ribbon(aes(ymin = lower, ymax = upper), alpha = 0.4, fill = "red") + #quantiles
geom_line(aes(y = x_mean), colour = "red", size = 0.4, alpha = 0.75) + #mean estimate
geom_point(aes(y = actual), colour = "gray32", #actual observation points
size = 0.9, shape = 16, alpha = 0.9) +
ylab("log(outages_hrs)") +
scale_y_continuous(labels = function(x) paste0(x)) +
xlab("Event (outage x county)") +
ggtitle("Bayesian Additive Regression Tree") +
theme(plot.title = element_text(hjust = 0.5))
print(p)
}
plot_filtering_estimates(gg)
varimp = investigate_var_importance(bart, num_replicates_for_avg = 5)
pd_plot(bartY1, j = "customers_out")
pd_plot(bartY1, j = "SLP_mean")
pd_plot(bartY1, j = "PS_sd")
pd_plot(bartY1, j = "Density")
pd_plot(bartY1, j = "Factor1")
pd_plot(bartY1, j = "Factor2")
pd_plot(bartY1, j = "Factor3")
pd_plot(bartY1, j = "Factor4")
pd_plot(bartY1, j = "Factor5")
pd_plot(bartY1, j = "Factor1")
pd_plot(bartY1, j = "V_max")
## restrict to only big outages (80 or 90 percentile)
df_bart = data.frame(county_map_group_join) %>%
drop_na %>%
dplyr::filter(customers_out_perc < 1) %>% #remove bad data
dplyr::filter(hours <= quantile(county_map_group_join$hours, .9)) %>%
mutate(customer_out_hrs = customers_out / 1000 * hours) #Kilo customer_out_hrs
y1 = log(df_bart$hours)
X = df_bart %>%
dplyr::select(-outage_number, -GEOID, -customers_out_perc, -customer_out_hrs, -hours)
set.seed(32)
bartY1 = bartMachine(X, y1)
bart = bartY1
Y = y1
predictions = predict(bart, X)
CI = round(calc_credible_intervals(bart, X, ci_conf = 0.95), 2)
gg = dplyr::tibble(x_mean = predictions,
lower = CI[,1],
upper = CI[,2],
actual = Y
)
gg = arrange(gg, actual)
gg$index = seq.int(nrow(gg))
plot_filtering_estimates <- function(df) {
p <- ggplot(data = gg, aes(x = index)) +
theme_classic() +
geom_ribbon(aes(ymin = lower, ymax = upper), alpha = 0.4, fill = "red") + #quantiles
geom_line(aes(y = x_mean), colour = "red", size = 0.4, alpha = 0.75) + #mean estimate
geom_point(aes(y = actual), colour = "gray32", #actual observation points
size = 0.9, shape = 16, alpha = 0.9) +
ylab("log(outages_hrs)") +
scale_y_continuous(labels = function(x) paste0(x)) +
xlab("Event (outage x county)") +
ggtitle("Bayesian Additive Regression Tree") +
theme(plot.title = element_text(hjust = 0.5))
print(p)
}
plot_filtering_estimates(gg)
varimp = investigate_var_importance(bart, num_replicates_for_avg = 5)
check_bart_error_assumptions(bart)
plot_convergence_diagnostics(bart)
pd_plot(bartY1, j = "customers_out")
pd_plot(bartY1, j = "PS_sd")
pd_plot(bartY1, j = "T_sd")
pd_plot(bartY1, j = "TQI_max")
pd_plot(bartY1, j = "TQI_mean")
pd_plot(bartY1, j = "T_mean")
pd_plot(bartY1, j = "Factor1")
pd_plot(bartY1, j = "Factor4")
pd_plot(bartY1, j = "Factor2")
pd_plot(bartY1, j = "Factor5")
pd_plot(bartY1, j = "Factor3")
