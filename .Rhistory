# step_normalize(all_predictors()) %>% #z-score standardize all predictors (important for PLS or NN)
step_zv(all_predictors()) %>% #removes predictors of single value
step_corr(all_predictors())  #removes highly correlated
prep(hours_recipe) #shows changes
## Specify models
# BART
df_bart = prep(hours_recipe) %>% juice(df_train)
## Specify models
# BART
df_bart = prep(hours_recipe) %>% juice()
df_split
df_split$out_id
df_split$in_id
## Specify models
# BART
df_bart = prep(hours_recipe) %>% juice()
df_bart_train = df_bart %>% slice(df_split$in_id)
y = df_data %>% dplyr::select(ln_hrs) %>% slice(df_split$in_id)
X = df_bart_train
## Specify models
model_name = paste("Large Events - Static, Socio-economic, and Dynamic Variables")
?bartMachineCV
bart_fit = bartMachineCV(X, y, k_folds = 10)
y = df_data %>% dplyr::select(ln_hrs) %>% slice(df_split$in_id) %>% as.vector()
y = as.vector(df_data %>% dplyr::select(ln_hrs) %>% slice(df_split$in_id))
y = as.vector(df_data %>% dplyr::select(ln_hrs) %>% slice(df_split$in_id))
y = df_data %>% dplyr::select(ln_hrs) %>% slice(df_split$in_id) %>% pull()
X = df_bart_train
bart_fit = bartMachineCV(X, y, k_folds = 10)
class(X)
X = data.frame(df_bart_train)
class(X)
bart_fit = bartMachineCV(X, y, k_folds = 10)
df_bart_test = df_bart %>% slice(!df_split$in_id)
df_bart_test = df_bart %>% slice(-df_split$in_id)
X_test = data.frame(df_bart_test)
predictions = predict(bartMachineCV, X_test)
predictions = predict(bart_fit, X_test)
bart_pred = predict(bart_fit, X_test)
View(df_bart_test)
bart_rmse = sqrt(mean((bart_pred - df_bart_test$ln_hrs)^2))
summary(df_bart)
df_bart_train = df_bart %>% slice(df_split$in_id) %>% dplyr::select(-ln_hrs)
X = data.frame(df_bart_train)
y = df_bart %>% dplyr::select(ln_hrs) %>% slice(df_split$in_id) %>% pull()
bart_fit = bartMachineCV(X, y, k_folds = 10)
df_bart_test = df_bart %>% slice(-df_split$in_id) %>% dplyr::select(-ln_hrs)
X_test = data.frame(df_bart_test)
bart_pred = predict(bart_fit, X_test)
bart_rmse = sqrt(mean((bart_pred - df_bart_test$ln_hrs)^2))
y_test = df_bart %>% slice(-df_split$in_id) %>% dplyr::select(ln_hrs)
bart_rmse = sqrt(mean((bart_pred - y_test)^2))
y_test = df_bart %>% slice(-df_split$in_id) %>% dplyr::select(ln_hrs) %>% pull()
bart_rmse = sqrt(mean((bart_pred - y_test)^2))
bart_rsq = 1 - sum((y_test - bart_pred)^2) / sum((y_test - mean(y_test))^2)
# Random Forest
#https://www.rebeccabarter.com/blog/2020-03-25_machine_learning/
show_model_info("rand_forest")
rf_model = rand_forest(mtry = tune(), trees = tune(), min_n = tune()) %>%
set_engine("ranger", importance = "permutation") %>%
set_mode("regression")
rf_work = workflow() %>%
add_recipe(hours_recipe) %>%
add_model(rf_model)
rf_grid = expand.grid(mtry = c(1, 3, 5), trees = c(100, 500, 1000), min_n = c(3, 5, 10))
rf_tune = rf_work %>%
tune_grid(resamples = df_cv,
grid = rf_grid,
metrics = metric_set(yardstick::rmse, yardstick::rsq))
show_best(rf_tune, metric = "rmse")
rf_tune_results = rf_tune %>% collect_metrics()
rf_best = rf_tune %>% select_best(metric = "rmse")
rf_fit = rf_work %>%
finalize_workflow(rf_best) %>%
last_fit(df_split)
rf_test = rf_fit %>% collect_metrics() #metrics evaluated on test sample (b/c last_fit() function)
rf_predictions = rf_fit %>% collect_predictions() #predictions for test sample (b/c last_fit() function)
# Lasso/Ridge/ElasticNet
#https://dnield.com/posts/tidymodels-intro/
show_model_info("linear_reg")
lre_model = linear_reg(penalty = tune(), mixture = tune()) %>%
set_engine("glmnet")
lre_work = workflow() %>%
add_recipe(hours_recipe) %>%
add_model(lre_model)
lre_grid = grid_regular(parameters(penalty(), mixture()), levels = c(5, 5))
lre_tune = lre_work %>%
tune_grid(resamples = df_cv,
grid = lre_grid,
metrics = metric_set(yardstick::rmse, yardstick::rsq))
show_best(lre_tune, metric = "rmse")
lre_tune_results = lre_tune %>% collect_metrics()
lre_best = lre_tune %>% select_best(metric = "rmse")
lre_fit = lre_work %>%
finalize_workflow(lre_best) %>%
last_fit(df_split)
lre_test = lre_fit %>% collect_metrics() #metrics evaluated on test sample (b/c last_fit() function)
lre_predictions = lre_fit %>% collect_predictions() #predictions for test sample (b/c last_fit() function)
bart_CI = round(calc_credible_intervals(bart_fit, X_test, ci_conf = 0.95), 2)
gg = dplyr::tibble(predictions = bart_pred,
lower = CI[,1],
upper = CI[,2],
actual = y,
rf = rf_predictions$.pred,
lre = lre_predictions$.pred
)
gg = dplyr::tibble(predictions = bart_pred,
lower = bart_CI[,1],
upper = bart_CI[,2],
actual = y,
rf = rf_predictions$.pred,
lre = lre_predictions$.pred
)
gg = dplyr::tibble(predictions = bart_pred,
lower = bart_CI[,1],
upper = bart_CI[,2],
actual = y,
rf = as.vector(rf_predictions$.pred),
lre = as.vector(lre_predictions$.pred)
)
gg = dplyr::tibble(predictions = bart_pred,
lower = bart_CI[,1],
upper = bart_CI[,2],
actual = y_test,
rf = as.vector(rf_predictions$.pred),
lre = as.vector(lre_predictions$.pred)
)
gg = arrange(gg, actual)
gg$index = seq.int(nrow(gg))
gg$Ymean = mean(gg$actual, na.rm = T)
plot_filtering_estimates2 <- function(df) {
p <- ggplot(data = gg, aes(x = index)) +
theme_classic() +
geom_ribbon(aes(ymin = lower, ymax = upper, fill = "indianred"), alpha = 0.5) + #credible intervals
geom_line(aes(y = predictions, colour = "red"), size = 0.25, alpha = .9) + #prediction point estimate
geom_point(aes(y = actual, colour = "black"), size = 0.55, shape = 16, alpha = 0.9) + #actual observation points
geom_line(aes(y = Ymean, colour = "blue"), size = 0.55, lty = "solid", alpha = 0.9) + #null model (mean only)
ylab("Outage Duration (log hours)") +
#ylab("Max Cust. Outages (log)") +
scale_y_continuous(labels = function(x) paste0(x)) +
xlab("Outage Index (event x county)") +
ggtitle(model_name) +
scale_fill_identity(name = "fill", guide = 'legend', labels = c('95% CI')) +
scale_colour_manual(name = 'colour',
values = c('black',"blue", "red"),
labels = c('Actual', 'Mean', 'BART'),
guide = guide_legend(
reverse = T,
override.aes = list(
linetype = c("solid", "solid","blank"),
shape = c(NA, NA, 16))
)) +
theme(plot.title = element_text(hjust = 0.5),
legend.title = element_blank(),
legend.direction = "vertical",
legend.box = "horizontal",
legend.position = c(.25, .75) #x and y percentage
) +
annotate("text", x = quantile(gg$index, 0.8), y = quantile(gg$actual, .05), label=lb1, parse=T, color="red", size = 3)
print(p)
}
plot_filtering_estimates2(gg)
plot_filtering_estimates2 <- function(df) {
p <- ggplot(data = gg, aes(x = index)) +
theme_classic() +
geom_ribbon(aes(ymin = lower, ymax = upper, fill = "indianred"), alpha = 0.5) + #credible intervals
geom_line(aes(y = predictions, colour = "red"), size = 0.25, alpha = .9) + #prediction point estimate
geom_point(aes(y = actual, colour = "black"), size = 0.55, shape = 16, alpha = 0.9) + #actual observation points
geom_line(aes(y = Ymean, colour = "blue"), size = 0.55, lty = "solid", alpha = 0.9) + #null model (mean only)
ylab("Outage Duration (log hours)") +
#ylab("Max Cust. Outages (log)") +
scale_y_continuous(labels = function(x) paste0(x)) +
xlab("Outage Index (event x county)") +
ggtitle(model_name) +
scale_fill_identity(name = "fill", guide = 'legend', labels = c('95% CI')) +
scale_colour_manual(name = 'colour',
values = c('black',"blue", "red"),
labels = c('Actual', 'Mean', 'BART'),
guide = guide_legend(
reverse = T,
override.aes = list(
linetype = c("solid", "solid","blank"),
shape = c(NA, NA, 16))
)) +
theme(plot.title = element_text(hjust = 0.5),
legend.title = element_blank(),
legend.direction = "vertical",
legend.box = "horizontal",
legend.position = c(.25, .75) #x and y percentage
) +
annotate("text", x = quantile(gg$index, 0.8), y = quantile(gg$actual, .05), label=lb1, parse=T, color="red", size = 3)
print(p)
}
plot_filtering_estimates2(gg)
plot_filtering_estimates2 <- function(df) {
p <- ggplot(data = gg, aes(x = index)) +
theme_classic() +
geom_ribbon(aes(ymin = lower, ymax = upper, fill = "indianred"), alpha = 0.5) + #credible intervals
geom_line(aes(y = predictions, colour = "red"), size = 0.25, alpha = .9) + #prediction point estimate
geom_point(aes(y = actual, colour = "black"), size = 0.55, shape = 16, alpha = 0.9) + #actual observation points
geom_line(aes(y = Ymean, colour = "blue"), size = 0.55, lty = "solid", alpha = 0.9) + #null model (mean only)
ylab("Outage Duration (log hours)") +
#ylab("Max Cust. Outages (log)") +
scale_y_continuous(labels = function(x) paste0(x)) +
xlab("Outage Index (event x county)") +
ggtitle(model_name) +
scale_fill_identity(name = "fill", guide = 'legend', labels = c('95% CI')) +
scale_colour_manual(name = 'colour',
values = c('black',"blue", "red"),
labels = c('Actual', 'Mean', 'BART'),
guide = guide_legend(
reverse = T,
override.aes = list(
linetype = c("solid", "solid","blank"),
shape = c(NA, NA, 16))
)) +
theme(plot.title = element_text(hjust = 0.5),
legend.title = element_blank(),
legend.direction = "vertical",
legend.box = "horizontal",
legend.position = c(.25, .75) #x and y percentage
)
#annotate("text", x = quantile(gg$index, 0.8), y = quantile(gg$actual, .05), label=lb1, parse=T, color="red", size = 3)
print(p)
}
function (geom, x = NULL, y = NULL, xmin = NULL, xmax = NULL,
ymin = NULL, ymax = NULL, xend = NULL, yend = NULL, ...,
na.rm = FALSE)
plot_filtering_estimates2 <- function(df) {
p <- ggplot(data = gg, aes(x = index)) +
theme_classic() +
geom_ribbon(aes(ymin = lower, ymax = upper, fill = "indianred"), alpha = 0.5) + #credible intervals
geom_line(aes(y = predictions, colour = "red"), size = 0.25, alpha = .9) + #prediction point estimate
geom_point(aes(y = actual, colour = "black"), size = 0.55, shape = 16, alpha = 0.9) + #actual observation points
geom_line(aes(y = Ymean, colour = "blue"), size = 0.55, lty = "solid", alpha = 0.9) + #null model (mean only)
ylab("Outage Duration (log hours)") +
#ylab("Max Cust. Outages (log)") +
scale_y_continuous(labels = function(x) paste0(x)) +
xlab("Outage Index (event x county)") +
ggtitle(model_name) +
scale_fill_identity(name = "fill", guide = 'legend', labels = c('95% CI')) +
scale_colour_manual(name = 'colour',
values = c('black',"blue", "red"),
labels = c('Actual', 'Mean', 'BART'),
guide = guide_legend(
reverse = T,
override.aes = list(
linetype = c("solid", "solid","blank"),
shape = c(NA, NA, 16))
)) +
theme(plot.title = element_text(hjust = 0.5),
legend.title = element_blank(),
legend.direction = "vertical",
legend.box = "horizontal",
legend.position = c(.25, .75) #x and y percentage
)
#annotate("text", x = quantile(gg$index, 0.8), y = quantile(gg$actual, .05), label=lb1, parse=T, color="red", size = 3)
print(p)
}
plot_filtering_estimates2(gg)
plot_filtering_estimates2 <- function(df) {
p <- ggplot(data = gg, aes(x = index)) +
theme_classic() +
geom_ribbon(aes(ymin = lower, ymax = upper, fill = "indianred"), alpha = 0.5) + #credible intervals
geom_line(aes(y = predictions, colour = "red"), size = 0.25, alpha = .9) + #prediction point estimate
geom_point(aes(y = actual, colour = "black"), size = 0.55, shape = 16, alpha = 0.9) + #actual observation points
geom_line(aes(y = Ymean, colour = "blue"), size = 0.55, lty = "solid", alpha = 0.9) + #null model (mean only)
geom_line(aes(y = rf, colour = "orange"), size = 0.55, lty = "solid", alpha = 0.9) + #null model (mean only)
ylab("Outage Duration (log hours)") +
#ylab("Max Cust. Outages (log)") +
scale_y_continuous(labels = function(x) paste0(x)) +
xlab("Outage Index (event x county)") +
ggtitle(model_name) +
scale_fill_identity(name = "fill", guide = 'legend', labels = c('95% CI')) +
scale_colour_manual(name = 'colour',
values = c("orange", 'black',"blue", "red"),
labels = c("RF",'Actual', 'Mean', 'BART'),
guide = guide_legend(
reverse = T,
override.aes = list(
linetype = c("solid", "solid", "solid","blank"),
shape = c(NA, NA, NA, 16))
)) +
theme(plot.title = element_text(hjust = 0.5),
legend.title = element_blank(),
legend.direction = "vertical",
legend.box = "horizontal",
legend.position = c(.25, .75) #x and y percentage
)
#annotate("text", x = quantile(gg$index, 0.8), y = quantile(gg$actual, .05), label=lb1, parse=T, color="red", size = 3)
print(p)
}
plot_filtering_estimates2(gg)
plot_filtering_estimates2 <- function(df) {
p <- ggplot(data = gg, aes(x = index)) +
theme_classic() +
geom_ribbon(aes(ymin = lower, ymax = upper, fill = "indianred"), alpha = 0.5) + #credible intervals
geom_line(aes(y = predictions, colour = "red"), size = 0.25, alpha = .9) + #prediction point estimate
geom_point(aes(y = actual, colour = "black"), size = 0.55, shape = 16, alpha = 0.9) + #actual observation points
geom_line(aes(y = Ymean, colour = "blue"), size = 0.55, lty = "solid", alpha = 0.9) + #null model (mean only)
geom_line(aes(y = rf, colour = "orange"), size = 0.55, lty = "solid", alpha = 0.9) + #null model (mean only)
ylab("Outage Duration (log hours)") +
#ylab("Max Cust. Outages (log)") +
scale_y_continuous(labels = function(x) paste0(x)) +
xlab("Outage Index (event x county)") +
ggtitle(model_name) +
#scale_fill_identity(name = "fill", guide = 'legend', labels = c('95% CI')) +
scale_colour_manual(name = 'colour',
#values = c("orange", 'black',"blue", "red"),
labels = c("RF",'Actual', 'Mean', 'BART'),
# guide = guide_legend(
#   reverse = T,
#   override.aes = list(
#     linetype = c("solid", "solid", "solid","blank"),
#     shape = c(NA, NA, NA, 16))
# )
) +
theme(plot.title = element_text(hjust = 0.5),
legend.title = element_blank(),
legend.direction = "vertical",
legend.box = "horizontal",
legend.position = c(.25, .75) #x and y percentage
)
#annotate("text", x = quantile(gg$index, 0.8), y = quantile(gg$actual, .05), label=lb1, parse=T, color="red", size = 3)
print(p)
}
plot_filtering_estimates2(gg)
plot_filtering_estimates2 <- function(df) {
p <- ggplot(data = gg, aes(x = index)) +
theme_classic() +
geom_ribbon(aes(ymin = lower, ymax = upper, fill = "indianred"), alpha = 0.5) + #credible intervals
geom_line(aes(y = predictions), size = 0.25, alpha = .9) + #prediction point estimate
geom_point(aes(y = actual), size = 0.55, shape = 16, alpha = 0.9) + #actual observation points
geom_line(aes(y = Ymean), size = 0.55, lty = "solid", alpha = 0.9) + #null model (mean only)
geom_line(aes(y = rf), size = 0.55, lty = "solid", alpha = 0.9) + #null model (mean only)
ylab("Outage Duration (log hours)") +
#ylab("Max Cust. Outages (log)") +
scale_y_continuous(labels = function(x) paste0(x)) +
xlab("Outage Index (event x county)") +
ggtitle(model_name) +
#scale_fill_identity(name = "fill", guide = 'legend', labels = c('95% CI')) +
scale_colour_manual(name = 'colour',
#values = c("orange", 'black',"blue", "red"),
labels = c("RF",'Actual', 'Mean', 'BART'),
# guide = guide_legend(
#   reverse = T,
#   override.aes = list(
#     linetype = c("solid", "solid", "solid","blank"),
#     shape = c(NA, NA, NA, 16))
# )
) +
theme(plot.title = element_text(hjust = 0.5),
legend.title = element_blank(),
legend.direction = "vertical",
legend.box = "horizontal",
legend.position = c(.25, .75) #x and y percentage
)
#annotate("text", x = quantile(gg$index, 0.8), y = quantile(gg$actual, .05), label=lb1, parse=T, color="red", size = 3)
print(p)
}
plot_filtering_estimates2(gg)
plot_filtering_estimates2 <- function(df) {
p <- ggplot(data = gg, aes(x = index)) +
theme_classic() +
geom_ribbon(aes(ymin = lower, ymax = upper, fill = "indianred"), alpha = 0.5) + #credible intervals
geom_line(aes(y = predictions, colour = "red"), size = 0.25, alpha = .9) + #prediction point estimate
geom_point(aes(y = actual, colour = "black"), size = 0.55, shape = 16, alpha = 0.9) + #actual observation points
geom_line(aes(y = Ymean, colour = "blue"), size = 0.55, lty = "solid", alpha = 0.9) + #null model (mean only)
geom_line(aes(y = rf, colour = "orange"), size = 0.55, lty = "solid", alpha = 0.9) + #null model (mean only)
ylab("Outage Duration (log hours)") +
#ylab("Max Cust. Outages (log)") +
scale_y_continuous(labels = function(x) paste0(x)) +
xlab("Outage Index (event x county)") +
ggtitle(model_name) +
#scale_fill_identity(name = "fill", guide = 'legend', labels = c('95% CI')) +
# scale_colour_manual(name = 'colour',
#                     values = c("orange", 'black',"blue", "red"),
#                     labels = c("RF",'Actual', 'Mean', 'BART'),
#                     guide = guide_legend(
#                       reverse = T,
#                       override.aes = list(
#                         linetype = c("solid", "solid", "solid","blank"),
#                         shape = c(NA, NA, NA, 16))
#                     )) +
theme(plot.title = element_text(hjust = 0.5),
legend.title = element_blank(),
legend.direction = "vertical",
legend.box = "horizontal",
legend.position = c(.25, .75) #x and y percentage
)
#annotate("text", x = quantile(gg$index, 0.8), y = quantile(gg$actual, .05), label=lb1, parse=T, color="red", size = 3)
print(p)
}
plot_filtering_estimates2(gg)
plot_filtering_estimates2 <- function(df) {
p <- ggplot(data = gg, aes(x = index)) +
theme_classic() +
geom_ribbon(aes(ymin = lower, ymax = upper, fill = "indianred"), alpha = 0.5) + #credible intervals
geom_line(aes(y = predictions, colour = "red"), size = 0.25, alpha = .9) + #prediction point estimate
geom_point(aes(y = actual, colour = "black"), size = 0.55, shape = 16, alpha = 0.9) + #actual observation points
geom_line(aes(y = Ymean, colour = "blue"), size = 0.55, lty = "solid", alpha = 0.9) + #null model (mean only)
geom_line(aes(y = rf, colour = "orange"), size = 0.55, lty = "solid", alpha = 0.9) + #null model (mean only)
ylab("Outage Duration (log hours)") +
#ylab("Max Cust. Outages (log)") +
scale_y_continuous(labels = function(x) paste0(x)) +
xlab("Outage Index (event x county)") +
ggtitle(model_name) +
scale_fill_identity(name = "fill", guide = 'legend', labels = c('95% CI')) +
scale_colour_manual(name = 'colour',
values = c("orange", 'black',"blue", "red"),
labels = c("RF",'Actual', 'Mean', 'BART'),
guide = guide_legend(
reverse = T,
override.aes = list(
linetype = c("solid", "solid", "solid","blank"),
shape = c(NA, NA, NA, 16))
)) +
theme(plot.title = element_text(hjust = 0.5),
legend.title = element_blank(),
legend.direction = "vertical",
legend.box = "horizontal",
legend.position = c(.25, .75) #x and y percentage
)
#annotate("text", x = quantile(gg$index, 0.8), y = quantile(gg$actual, .05), label=lb1, parse=T, color="red", size = 3)
print(p)
}
plot_filtering_estimates2(gg)
plot_filtering_estimates2 <- function(df) {
p <- ggplot(data = gg, aes(x = index)) +
theme_classic() +
geom_ribbon(aes(ymin = lower, ymax = upper, fill = "indianred"), alpha = 0.5) + #credible intervals
geom_line(aes(y = predictions, colour = "red"), size = 0.25, alpha = .9) + #prediction point estimate
geom_point(aes(y = actual, colour = "black"), size = 0.55, shape = 16, alpha = 0.9) + #actual observation points
geom_line(aes(y = Ymean, colour = "blue"), size = 0.55, lty = "solid", alpha = 0.9) + #null model (mean only)
geom_line(aes(y = rf, colour = "orange"), size = 0.55, lty = "solid", alpha = 0.9) + #null model (mean only)
ylab("Outage Duration (log hours)") +
#ylab("Max Cust. Outages (log)") +
scale_y_continuous(labels = function(x) paste0(x)) +
xlab("Outage Index (event x county)") +
ggtitle(model_name) +
scale_fill_identity(name = "fill", guide = 'legend', labels = c('95% CI')) +
scale_colour_manual(name = 'colour',
values = c("orange", 'black',"blue", "red"),
#labels = c("RF",'Actual', 'Mean', 'BART'),
guide = guide_legend(
reverse = T,
override.aes = list(
linetype = c("solid", "solid", "solid","blank"),
shape = c(NA, NA, NA, 16))
)) +
theme(plot.title = element_text(hjust = 0.5),
legend.title = element_blank(),
legend.direction = "vertical",
legend.box = "horizontal",
legend.position = c(.25, .75) #x and y percentage
)
#annotate("text", x = quantile(gg$index, 0.8), y = quantile(gg$actual, .05), label=lb1, parse=T, color="red", size = 3)
print(p)
}
plot_filtering_estimates2(gg)
plot_filtering_estimates2 <- function(df) {
p <- ggplot(data = gg, aes(x = index)) +
theme_classic() +
geom_ribbon(aes(ymin = lower, ymax = upper, fill = "indianred"), alpha = 0.5) + #credible intervals
geom_line(aes(y = predictions, colour = "red"), size = 0.25, alpha = .9) + #prediction point estimate
geom_point(aes(y = actual, colour = "black"), size = 0.55, shape = 16, alpha = 0.9) + #actual observation points
geom_line(aes(y = Ymean, colour = "blue"), size = 0.55, lty = "solid", alpha = 0.9) + #null model (mean only)
geom_line(aes(y = rf, colour = "orange"), size = 0.55, lty = "solid", alpha = 0.9) + #null model (mean only)
geom_line(aes(y = lre, colour = "green"), size = 0.55, lty = "solid", alpha = 0.9) + #null model (mean only)
ylab("Outage Duration (log hours)") +
#ylab("Max Cust. Outages (log)") +
scale_y_continuous(labels = function(x) paste0(x)) +
xlab("Outage Index (event x county)") +
ggtitle(model_name) +
scale_fill_identity(name = "fill", guide = 'legend', labels = c('95% CI')) +
scale_colour_manual(name = 'colour',
values = c("green", "orange", 'black',"blue", "red"),
#labels = c("RF",'Actual', 'Mean', 'BART'),
guide = guide_legend(
reverse = T,
override.aes = list(
linetype = c("solid", "solid", "solid", "solid","solid"),
shape = c(NA, NA, NA, NA, 16))
)) +
theme(plot.title = element_text(hjust = 0.5),
legend.title = element_blank(),
legend.direction = "vertical",
legend.box = "horizontal",
legend.position = c(.25, .75) #x and y percentage
)
#annotate("text", x = quantile(gg$index, 0.8), y = quantile(gg$actual, .05), label=lb1, parse=T, color="red", size = 3)
print(p)
}
plot_filtering_estimates2(gg)
show_best(lre_tune, metric = "rmse")
bart_fit$rmse_train
bart_fit$cv_stats
save.image("~/Documents/01_VECTOR.nosync/Sandia/Data/Sandia3_ml.RData")
lre_tune_results
View(lre_tune_results)
bart_fit$folds
bart_fit$cv_stats
?bartMachine
summary(bart_fit)
bart_fit
bart_fit$java_bart_machine
bart_fit$n
bart_fit$p
?bartMachineCV
?bartMachine
bart_fit$alpha
bart_fit$cv_stats
