acs_sub_w
sub_map
df_sub
View(df_sub)
### Subdivision
sub_map = get_acs(geography = "block group", state = state, county = county,
variables=c("B01003_001"), year = year, geometry = TRUE,
cache_table = TRUE)
sub_map = sub_map %>% select(GEOID, NAME)
acs_sub_w = acs_sub %>%
select(-moe, -NAME) %>% #remove errors of estimates because we're spreading by variable and don't want duplicates, and don't need name b/c joining by GEOID
spread(key=variable, value = estimate)
mapview(df_sub, zcol = c("QBLACK"), legend = TRUE, alpha.regions = 0.32)
acs_sub = get_acs(geography = "block group", state = state, county = county,
variables=acs_vars_use, year = year, geometry = FALSE)
df_sub = sub_map %>%
left_join(acs_data_w, by = "GEOID") %>% #join ACS_5yr data
mutate(QBLACK = B01001B_001 / B01003_001) %>%
mutate(QWHITE = B01001A_001 / B01003_001) %>%
dplyr::select(QWHITE, QBLACK)
df_sub
v18 = load_variables(2018, "acs5", cache = TRUE)
View(v18)
mapview(df, zcol = c("QBLACK"), legend = TRUE, alpha.regions = 0.32)
library(tidycensus) #api with census
library(sf) #class and functions for vector data
library(tidyverse) #collection of r data tools, including dplyr
library(mapview)
year=2018
state = "Alabama"
county = c("Madison")
county_map = county_map %>% select(GEOID, NAME)
acs_data = get_acs(geography = "tract", state = state, county = county,
variables=acs_vars_use, year = year, geometry = FALSE)
### Geometry base - US Counties
options(tigris_use_cache = TRUE) #to cache shapefiles for future sessions
county_map = get_acs(geography = "tract", state = state, county = county,
variables=c("B01003_001"), year = year, geometry = TRUE,
cache_table = TRUE)
### Data from ACS-5yr
acs_vars_use = c("B01001B_001", "B01001A_001", "B01003_001")
df = county_map %>%
left_join(acs_data_w, by = "GEOID") %>% #join ACS_5yr data
mutate(QBLACK = B01001B_001 / B01003_001) %>%
mutate(QWHITE = B01001A_001 / B01003_001) %>%
dplyr::select(QWHITE, QBLACK)
#long to wide format
acs_data_w = acs_data %>%
select(-moe, -NAME) %>% #remove errors of estimates because we're spreading by variable and don't want duplicates, and don't need name b/c joining by GEOID
spread(key=variable, value = estimate)
#long to wide format
acs_data_w = acs_data %>%
select(-moe, -NAME) %>% #remove errors of estimates because we're spreading by variable and don't want duplicates, and don't need name b/c joining by GEOID
spread(key=variable, value = estimate)
acs_data = get_acs(geography = "tract", state = state, county = county,
variables=acs_vars_use, year = year, geometry = FALSE)
#long to wide format
acs_data_w = acs_data %>%
select(-moe, -NAME) %>% #remove errors of estimates because we're spreading by variable and don't want duplicates, and don't need name b/c joining by GEOID
spread(key=variable, value = estimate)
df = county_map %>%
left_join(acs_data_w, by = "GEOID") %>% #join ACS_5yr data
mutate(QBLACK = B01001B_001 / B01003_001) %>%
mutate(QWHITE = B01001A_001 / B01003_001) %>%
dplyr::select(QWHITE, QBLACK)
mapview(df, zcol = c("QBLACK"), legend = TRUE, alpha.regions = 0.32)
# LIST OF VARIABLES
v18 = load_variables(2018, "acs5", cache = TRUE)
View(v18)
library(tidyverse)
library(readxl)
library(sf)
library(tidycensus)
library(tidycensus) #api with census
library(sf) #class and functions for vector data
library(tidyverse) #collection of r data tools, including dplyr
library(mapview)
year=2018
### Geometry base - US Counties
options(tigris_use_cache = TRUE) #to cache shapefiles for future sessions
state = "Texas"
county = c("Harris")
county_map = get_acs(geography = "tract", state = state, county = county,
variables=c("B01003_001"), year = year, geometry = TRUE,
cache_table = TRUE)
county = c("Harris County")
county_map = get_acs(geography = "tract", state = state, county = county,
variables=c("B01003_001"), year = year, geometry = TRUE,
cache_table = TRUE)
View(county_map)
county_map = county_map %>% select(GEOID, NAME)
### Data from ACS-5yr
acs_vars_use = c("B01001B_001", "B01001A_001", "B01003_001")
acs_data = get_acs(geography = "tract", state = state, county = county,
variables=acs_vars_use, year = year, geometry = FALSE)
#long to wide format
acs_data_w = acs_data %>%
select(-moe, -NAME) %>% #remove errors of estimates because we're spreading by variable and don't want duplicates, and don't need name b/c joining by GEOID
spread(key=variable, value = estimate)
df = county_map %>%
left_join(acs_data_w, by = "GEOID") %>% #join ACS_5yr data
mutate(QBLACK = B01001B_001 / B01003_001) %>%
mutate(QWHITE = B01001A_001 / B01003_001) %>%
dplyr::select(QWHITE, QBLACK)
white = df %>%
ggplot(aes(fill = QWHITE)) +
geom_sf(color = NA) +
scale_fill_viridis_c(option = "magma")
plot(white)
View(county_map)
write.csv(county_map, "/Users/paulmj/Documents/01_VECTOR/UH_CIVIC/Harris_census_2018.csv", row.names = TRUE)
county_map2 = county_map %>%
st_geometry(NULL)
county_map2 = county_map %>%
st_set_geometry(NULL)
write.csv(county_map2, "/Users/paulmj/Documents/01_VECTOR/UH_CIVIC/Harris_census_2018.csv", row.names = TRUE)
year=2019
### Geometry base - US Counties
options(tigris_use_cache = TRUE) #to cache shapefiles for future sessions
state = "Texas"
county = c("Harris County")
county_map = get_acs(geography = "tract", state = state, county = county,
variables=c("B01003_001"), year = year, geometry = TRUE,
cache_table = TRUE)
county_map = county_map %>% select(GEOID, NAME)
### Data from ACS-5yr
acs_vars_use = c("B01001B_001", "B01001A_001", "B01003_001")
acs_data = get_acs(geography = "tract", state = state, county = county,
variables=acs_vars_use, year = year, geometry = FALSE)
#long to wide format
acs_data_w = acs_data %>%
select(-moe, -NAME) %>% #remove errors of estimates because we're spreading by variable and don't want duplicates, and don't need name b/c joining by GEOID
spread(key=variable, value = estimate)
df = county_map %>%
left_join(acs_data_w, by = "GEOID") %>% #join ACS_5yr data
mutate(QBLACK = B01001B_001 / B01003_001) %>%
mutate(QWHITE = B01001A_001 / B01003_001) %>%
dplyr::select(QWHITE, QBLACK)
white = df %>%
ggplot(aes(fill = QWHITE)) +
geom_sf(color = NA) +
scale_fill_viridis_c(option = "magma")
black = df %>%
ggplot(aes(fill = QBLACK)) +
geom_sf(color = NA) +
scale_fill_viridis_c(option = "magma")
county_map2 = county_map %>%
st_set_geometry(NULL)
write.csv(county_map2, "/Users/paulmj/Documents/01_VECTOR/UH_CIVIC/Harris_censustract_2019acs.csv", row.names = TRUE)
year=2020
### Geometry base - US Counties
options(tigris_use_cache = TRUE) #to cache shapefiles for future sessions
state = "Texas"
county = c("Harris County")
county_map = get_acs(geography = "tract", state = state, county = county,
variables=c("B01003_001"), year = year, geometry = TRUE,
cache_table = TRUE)
?get_acs
county_map = get_acs(geography = "tract", state = state, county = county,
variables=c("B01003_001"), year = 2020, geometry = TRUE,
cache_table = TRUE, survey = "acs1")
county_map = get_acs(geography = "tract", state = state, county = county,
variables=c("B01003_001"), year = 2019, geometry = TRUE,
cache_table = TRUE, survey = "acs1")
county_map = get_acs(geography = "tract", state = state, county = county,
variables=c("B01003_001"), year = 2019, geometry = TRUE,
cache_table = TRUE, survey = "acs5")
county_map = get_acs(geography = "tract", state = state, county = county,
variables=c("B01003_001"), year = 2019, geometry = TRUE,
cache_table = TRUE, survey = "acs1")
county_map = get_acs(geography = "tract", state = state, county = county,
variables=c("B01003_001"), year = 2020, geometry = TRUE,
cache_table = TRUE, survey = "acs1")
county_map = get_acs(geography = "tract", state = state, county = county,
variables=c("B01003_001"), year = 2021, geometry = TRUE,
cache_table = TRUE, survey = "acs1")
county_map = get_acs(geography = "tract", state = state, county = county,
variables=c("B01003_001"), year = 2019, geometry = TRUE,
cache_table = TRUE, survey = "acs1")
county_map = county_map %>% select(GEOID, NAME)
install.packages("stars")
library(tidyverse)
library(tidycensus)
library(sf)
library(terra)
library(stars)
load("~/Documents/01_VECTOR.nosync/Sandia/TX_group.Rda")
## Root zone data
TX_gdb =  "/Users/paulmj/Downloads/gSSURGO_TX/gSSURGO_TX.gdb"
TX_Valu1 = sf::st_read(dsn = TX_gdb, layer = "Valu1")
TX_group_val1 = TX_group %>% left_join(TX_Valu1, by = c("MUKEY" = "mukey"))
TX_group_val1_100 = TX_group_val1 %>%
filter(!is.na(rootznemc)) %>%
slice(1:100) %>%
select(MUKEY, rootznemc)
?st_rasterize
TX_rast100 = st_rasterize(TX_group_val1_100)
TX_rast100 = st_rasterize(TX_group_val1_100["rootznemc"])
plot(TX_rast100)
TX_rast = st_rasterize(TX_group_val1["rootznemc"])
plot(TX_rast)
rr = ggplot() +
geom_tile(data = TX_rast, aes(x = x, y = y, fill = rootznemc)) +
scale_fill_viridis_c()
rr = ggplot() +
geom_stars(data = TX_rast, aes(x = x, y = y, fill = rootznemc)) +
scale_fill_viridis_c()
rr
rr = ggplot() +
geom_stars(data = TX_rast, aes(x = x, y = y, fill = rootznemc)) +
scale_fill_viridis_c(direction = -1)
rr
rr = ggplot() +
#geom_stars(data = TX_rast, aes(x = x, y = y, fill = rootznemc)) +
geom_stars(data = TX_rast, aes(fill = rootznemc)) +
scale_fill_viridis_c(direction = -1)
rr
rr = ggplot() +
geom_stars(data = TX_rast, aes(x = x, y = y, fill = rootznemc)) +
scale_fill_viridis_c(direction = -1)
rr
rr = ggplot() +
geom_stars(data = TX_rast, aes(x = x, y = y, fill = rootznemc), alpha = 0.8) +
scale_fill_viridis_c(direction = -1)
rr
rr = ggplot() +
geom_stars(data = TX_rast, aes(x = x, y = y, fill = rootznemc), alpha = 0.9) +
scale_fill_viridis_c(direction = -1)
rr
rr = ggplot() +
geom_stars(data = TX_rast, aes(x = x, y = y, fill = rootznemc)) +
scale_fill_viridis_c(direction = -1)
rr
rr = ggplot() +
geom_stars(data = TX_rast, aes(x = x, y = y, fill = rootznemc)) +
scale_fill_viridis_c(direction = -1) +
theme_bw()
rr
rr = ggplot() +
geom_stars(data = TX_rast, aes(x = x, y = y, fill = rootznemc)) +
scale_fill_viridis_c(direction = -1) +
theme_classic()
rr
rr = ggplot() +
geom_stars(data = TX_rast, aes(x = x, y = y, fill = rootznemc)) +
scale_fill_viridis_c(direction = -1) +
theme_minimal()
rr
rr = ggplot() +
geom_stars(data = TX_rast, aes(x = x, y = y, fill = rootznemc)) +
scale_fill_viridis_c(direction = -1)
rr
rr = ggplot() +
geom_stars(data = TX_rast, aes(x = x, y = y, fill = rootznemc)) +
scale_fill_viridis_c(direction = -1, na.value = "white")
rr
rr = ggplot() +
geom_stars(data = TX_rast, aes(x = x, y = y, fill = rootznemc)) +
scale_fill_viridis_c(direction = -1, na.value = "gray")
rr
rr = ggplot() +
geom_stars(data = TX_rast, aes(x = x, y = y, fill = rootznemc)) +
scale_fill_viridis_c(direction = -1, na.value = "gray") +
theme_light()
rr
rr = ggplot() +
geom_stars(data = TX_rast, aes(x = x, y = y, fill = rootznemc)) +
scale_fill_viridis_c(direction = -1, na.value = "gray") +
theme_minimal()
rr
st_crs(TX_rast)
st_crs(TX_rast)$units_gdal
TX_rast_1k = st_rasterize(TX_group_val1["rootznemc"], dx = 1000, dy = 1000)
rr = ggplot() +
geom_stars(data = TX_rast_1k, aes(x = x, y = y, fill = rootznemc)) +
scale_fill_viridis_c(direction = -1, na.value = "gray") +
theme_minimal()
rr
install.packages("sqldf")
version
install.packages("sqldf")
install.packages("hurricaneexposure")
install.packages("caret")
install.packages("tidymodels")
install.packages("tune")
install.packages("workflows")
load("~/Documents/01_VECTOR.nosync/Sandia/Data/Sandia3_ml.RData")
options(java.parameters = "-Xmx7g")
library(bartMachine)
set_bart_machine_num_cores(4)
library(tidyverse)
library(tidymodels)
library(tidycensus)
library(sf)
library(lme4)
library(corrplot)
library(viridis)
#library(sqldf)
# GBM
show_model_info("boost_tree")
?dials
?set_engine
?ranger::importance
?ranger::ranger
?randomForest::randomForest
install.packages("xgboost")
?xgboost::xgb.train
gb_model = boost_tree(mode = "regression", trees = 1000,
min_n = tune(), tree_depth = tune(), learn_rate = tune(), loss_reduction = tune()) %>%
set_engine(engine = "xgboost")
gb_work = workflow() %>%
add_recipe(hours_recipe) %>%
add_model(gb_model)
gb_grid = dials::grid_max_entropy(parameters(min_n, tree_depth, learn_rate, loss_reduction), size = 100)
?min_n
gb_grid = dials::grid_max_entropy(parameters(min_n(), tree_depth(), learn_rate(), loss_reduction()), size = 100)
plot(gb_grid)
?tune_grid
gb_tune = gb_work %>%
tune_grid(resamples = df_cv,
grid = gb_grid,
metrics = metric_set(yardstick::rmse(), yardstick::rsq()))
gb_tune = gb_work %>%
tune_grid(resamples = df_cv,
grid = gb_grid,
metrics = metric_set(yardstick::rmse, yardstick::rsq))
?control_grid
gb_tune = gb_work %>%
tune_grid(resamples = df_cv,
grid = gb_grid,
metrics = metric_set(yardstick::rmse, yardstick::rsq),
control = tune::control_grid(verbose = T))
show_best(gb_tune, metric = "rmse")
save.image("~/Documents/01_VECTOR.nosync/Sandia/Data/Sandia3_ml.RData")
gb_tune_results = gb_tune %>% collect_metrics()
gb_best = gb_tune %>% select_best(metric = "rmse")
gb_fit = gb_work %>%
finalize_workflow(gb_best) %>%
last_fit(df_split)
gb_test = gb_fit %>% collect_metrics() #metrics evaluated on test sample (b/c last_fit() function)
gb_predictions = gb_fit %>% collect_predictions() #predictions for test sample (b/c last_fit() function)
save.image("~/Documents/01_VECTOR.nosync/Sandia/Data/Sandia3_ml.RData")
library(corrplot)
library(viridis)
library(tidyverse)
library(tidycensus)
library(sf)
library(terra)
library(stars)
library(raster) #make sure ncdf4 package is installed
library(lubridate)
setwd("~/Documents/01_VECTOR.nosync/Sandia")
##################################################################################################
#### CREATE CENSUS MAP ###########################################################################
##################################################################################################
mycrs = 5070 #chose projected coordinate system: EPSG 5070 NAD83 Conus Albers
year=2019 # year for county boundaries
# Get map
options(tigris_use_cache = TRUE) #cache shapefiles for future sessions
soptions(tigris_use_cache = TRUE) #to cache shapefiles for future sessions
state = "Texas"
county = c("Harris County")
census_map = get_acs(geography = "tract", state = state, county = county,
variables=c("B01003_001"), year = year, geometry = TRUE,
cache_table = TRUE)
census_map = census_map %>%
mutate(POPULATION = estimate) %>%
dplyr::select(GEOID, NAME, POPULATION) %>%
st_transform(mycrs) # project to Conic Equal Area Albers, EPSG:5070
# Calculate area and population density of each county
census_map_area = census_map %>%
mutate(AREA = as.vector(st_area(census_map))) %>% #sq-meters; as.vector removes units suffix
mutate(DENSITY = POPULATION / AREA * 1000^2) #population per sq-km
## WIND SPEED - forecasts from StormGeo
hurricane.frcst.files = list.files(path = "./Data/StormGEO/HarveyNC", full.names = T, pattern = "\\.nc$") #get forecast (NCDF4 format)
hurricane.frcst.raster = lapply(hurricane.frcst.files, function(i){raster::raster(i, varname = "wspd")}) #read list of files as rasters
hurricane.frcst.raster[[1]]
hurricane.frcst.proj = lapply(hurricane.frcst.raster, function(i){raster::projectRaster(i, crs = crs(census_map_area))}) #project into crs
hurricane.frcst.terra = lapply(hurricane.frcst.proj, function(i){terra::rast(i)}) #convert to Spat Raster for easier masking and extraction
hurricane.frcst.crop = lapply(hurricane.frcst.terra,
function(i){
if("try-error" %in% class(try(terra::crop(i, vect(census_map_area)), silent = T))){NULL}
else {terra::crop(i, vect(census_map_area))}
}
) #crop to map and assign NULL for when the extents do not overlap
hurricane.frcst.crop[[1]]
hurricane.frcst.mask = lapply(hurricane.frcst.crop,
function(i){
if("try-error" %in% class(try(terra::mask(i, vect(census_map_area)), silent = T))){NULL}
else {terra::mask(i, vect(census_map_area))}
}
) #mask map and assign NULL for when the extents do not overlap
hurricane.frcst.mask[[1]]
hurricane.frcst.extract = lapply(hurricane.frcst.mask,
function(i){
if("try-error" %in% class(try(terra::extract(i, vect(census_map_area)), silent = T))){NULL}
else {terra::extract(i, vect(census_map_area))}
}
) #extract values to census tracts
hurricane.frcst.extract[[1]]
is.null(hurricane.frcst.extract[[1]])
hurricane.frcst.group = lapply(hurricane.frcst.mask,
function(i){
if(is.null(i)){NULL}
else {i %>% group_by(ID) %>% summarize(WIND_mean = mean(X10.meter.Windspeed, na.rm = TRUE))}
}
) #group extracted values by census tract
hurricane.frcst.group = lapply(hurricane.frcst.extract,
function(i){
if(is.null(i)){NULL}
else {i %>% group_by(ID) %>% summarize(WIND_mean = mean(X10.meter.Windspeed, na.rm = TRUE))}
}
) #group extracted values by census tract
hurricane.frcst.maps = lapply(hurricane.frcst.group,
function(i){
if(is.null(i)){NULL}
else {census_map_area %>% bind_cols(i)}
}
) #group extracted values by census tract
gg2 = ggplot(hurricane.frcst.maps[[90]])+
geom_sf(aes(fill = WIND_mean), color = NA) +
#scale_fill_viridis_c(option="plasma", na.value = "grey50") +
scale_fill_viridis_c(option="plasma", na.value = "skyblue") +
#geom_sf(fill = NA, show.legend = F, color = "black", lwd = 0.005)+
#coord_sf(datum = NA) + #removes gridlines
#guides(fill = "none") + #removes legend
#theme_minimal()  #removes background
theme_dark() +
#labs(title = "NLCD Land Use", fill = "Developed\n(prop.)") +
theme(plot.title = element_text(hjust = 0.5),
axis.title.x = element_blank(),
axis.title.y = element_blank()
)
gg2
asd = data.frame(matrix(unlist(hurricane.frcst.group), nrow=length(l), byrow=TRUE))
asd = data.frame(matrix(unlist(hurricane.frcst.group), nrow=length(hurricane.frcst.group), byrow=TRUE))
asd = data.frame(matrix(unlist(hurricane.frcst.group[90:121]), nrow=length(hurricane.frcst.group[90:121]), byrow=TRUE))
View(asd)
asd = as.data.frame(hurricane.frcst.group)
length(census_map)
nrow(census_map)
hurricane.frcst.group = lapply(hurricane.frcst.extract,
function(i){
if(is.null(i)){rep(NA, nrow(census_map))}
else {i %>% group_by(ID) %>% summarize(WIND_mean = mean(X10.meter.Windspeed, na.rm = TRUE))}
}
) #group extracted values by census tract
asd = as.data.frame(hurricane.frcst.group)
View(asd)
hurricane.frcst.df = as.data.frame(hurricane.frcst.group) %>%
dplyr::select(ID, contains(WIND_mean))
hurricane.frcst.df = as.data.frame(hurricane.frcst.group) %>%
dplyr::select(ID, contains("WIND_mean"))
View(hurricane.frcst.df)
hurricane.frcst.maps = census_map_area %>% bind_cols(hurricane.frcst.df)
hurricane.frcst.max = hurricane.frcst.maps %>%
dplyr::select(GEOID, contains("WIND_mean"))
?pmax
hurricane.frcst.max = hurricane.frcst.maps %>%
dplyr::select(GEOID, contains("WIND_mean")) %>%
mutate(WIND_max = do.call(pmax, hurricane.frcst.df[ ,2:ncol(hurricane.frcst.df)]))
hurricane.frcst.max = hurricane.frcst.maps %>%
#dplyr::select(GEOID, contains("WIND_mean")) %>%
mutate(WIND_max = do.call(pmax, hurricane.frcst.df[ , 2:ncol(hurricane.frcst.df)]))
hurricane.frcst.max = hurricane.frcst.maps %>%
#dplyr::select(GEOID, contains("WIND_mean")) %>%
mutate(WIND_max = do.call(pmax, hurricane.frcst.df[ , 2:ncol(hurricane.frcst.df)])) %>%
dplyr::select(GEOID, WIND_max)
?do.call
hurricane.frcst.max = hurricane.frcst.maps %>%
#dplyr::select(GEOID, contains("WIND_mean")) %>%
mutate(WIND_max = do.call(pmax(. , na.rm = T), hurricane.frcst.df[ , 2:ncol(hurricane.frcst.df)])) %>%
dplyr::select(GEOID, WIND_max)
hurricane.frcst.max = hurricane.frcst.maps %>%
hurricane.frcst.max = hurricane.frcst.maps %>%
#dplyr::select(GEOID, contains("WIND_mean")) %>%
mutate(WIND_max = do.call(function(x){pmax(x, na.rm = T)}, hurricane.frcst.df[ , 2:ncol(hurricane.frcst.df)])) %>%
dplyr::select(GEOID, WIND_max)
hurricane.frcst.max = hurricane.frcst.maps %>%
dplyr::select(GEOID, contains("WIND_mean")) %>%
mutate(WIND_max = pmax(2:ncol(hurricane.frcst.df), na.rm = T))
max_wind_names = hurricane.frcst.df %>% dplyr::select(contains("WIND_mean")) %>% names()
hurricane.frcst.max = hurricane.frcst.maps %>%
mutate(WIND_max = pmax(!!!rlang::syms(max_wind_names)))
hurricane.frcst.max = hurricane.frcst.maps %>%
mutate(WIND_max = pmax(!!!rlang::syms(max_wind_names), na.rm = T))
hurricane.frcst.max = hurricane.frcst.maps %>%
mutate(WIND_max = pmax(!!!rlang::syms(max_wind_names), na.rm = T))
summary(hurricane.frcst.max$WIND_max
)
hurricane.frcst.max = hurricane.frcst.maps %>%
mutate(WIND_max = pmax(!!!rlang::syms(max_wind_names), na.rm = T)) %>% # https://stackoverflow.com/questions/32978458/dplyr-mutate-rowwise-max-of-range-of-columns
dplyr::select(GEOID, WIND_max)
gg2 = ggplot(hurricane.frcst.max)+
geom_sf(aes(fill = WIND_max), color = NA) +
#scale_fill_viridis_c(option="plasma", na.value = "grey50") +
scale_fill_viridis_c(option="plasma", na.value = "skyblue") +
#geom_sf(fill = NA, show.legend = F, color = "black", lwd = 0.005)+
#coord_sf(datum = NA) + #removes gridlines
#guides(fill = "none") + #removes legend
#theme_minimal()  #removes background
theme_dark() +
#labs(title = "NLCD Land Use", fill = "Developed\n(prop.)") +
theme(plot.title = element_text(hjust = 0.5),
axis.title.x = element_blank(),
axis.title.y = element_blank()
)
gg2
census_map_WINDmax = hurricane.frcst.maps %>%
mutate(WIND_max = pmax(!!!rlang::syms(max_wind_names), na.rm = T)) %>% # https://stackoverflow.com/questions/32978458/dplyr-mutate-rowwise-max-of-range-of-columns
dplyr::select(GEOID, WIND_max)
save(census_map_WINDmax, file = "./Data/census_map_WINDmax.Rda")
