geom_ribbon(aes(ymin = lower, ymax = upper, fill = "indianred"), alpha = 0.5) + #credible intervals
geom_line(aes(y = predictions, colour = "red"), size = 0.25, alpha = .9) + #prediction point estimate
geom_point(aes(y = actual, colour = "black"), size = 0.55, shape = 16, alpha = 0.9) + #actual observation points
geom_line(aes(y = Ymean, colour = "blue"), size = 0.55, lty = "solid", alpha = 0.9) + #null model (mean only)
#ylab("Outage Duration (log hours)") +
ylab("Max Cust. Outages (log)") +
scale_y_continuous(labels = function(x) paste0(x)) +
xlab("Outage Index (event x county)") +
ggtitle(model_name) +
scale_fill_identity(name = "fill", guide = 'legend', labels = c('95% CI')) +
scale_colour_manual(name = 'colour',
values = c('black',"blue", "red"),
labels = c('Actual', 'Mean', 'BART'),
guide = guide_legend(
reverse = T,
override.aes = list(
linetype = c("solid", "solid","blank"),
shape = c(NA, NA, 16))
)) +
theme(plot.title = element_text(hjust = 0.5),
legend.title = element_blank(),
legend.direction = "vertical",
legend.box = "horizontal",
legend.position = c(.25, .75) #x and y percentage
) +
annotate("text", x = quantile(gg$index, 0.8), y = quantile(gg$actual, .05), label=lb1, parse=T, color="red", size = 3)
print(p)
}
plot_filtering_estimates2(gg)
# Feature selection (Kapelner and Bleich, 2016)
vs = var_selection_by_permute(bart, bottom_margin = 10, num_reps_for_avg = 20, num_permute_samples = 20, plot = F)
vs$important_vars_local_names
vs$important_vars_global_se_names
# Select only data we'll have available for prediction at the census tract level
county_outages_GROUP_CLEAN = county_outages_GROUP %>%
dplyr::select(-c(PS_mean:TQV_mean, AMBULANCES:DEATHS, EMPBLDG:HOSPBEDS, INTERNET:NURSHOMES, PHYSICIANS, PROFORGS:PROXCAP, RADIO:WATEFF)) %>%
dplyr::select(-c(QEXTRCT, QNRRES))
##############################################################################################################
#### MODELING ################################################################################################
##############################################################################################################
# Filter to large events (90th percentile in duration, > 12 hrs)
df_bart = data.frame(county_outages_GROUP_CLEAN) %>%
drop_na %>%
dplyr::filter(out_hrs > 12) #filter to big events
# y = log(df_bart$out_hrs) #take log to help deal with extreme values
y = log(df_bart$out_maxcust)
X = df_bart %>%
dplyr::select(-outage_number, -GEOID, -out_hrs, -out_maxcust, -out_percust)
model_name = paste("Predicting Max Outages - No Weather Data")
bart = bartMachine(X, y)
predictions = predict(bart, X)
CI = round(calc_credible_intervals(bart, X, ci_conf = 0.95), 2)
gg = dplyr::tibble(predictions = predictions,
lower = CI[,1],
upper = CI[,2],
actual = y
)
gg = arrange(gg, actual)
gg$index = seq.int(nrow(gg))
gg$Ymean = mean(gg$actual, na.rm = T)
rmse = sqrt(mean((gg$predictions - gg$actual)^2))
rsq = 1 - sum((gg$actual - gg$predictions)^2) / sum((gg$actual - mean(gg$actual))^2)
lb1 = paste("R^2 == ", round(rsq, 3))
plot_filtering_estimates2 <- function(df) {
p <- ggplot(data = gg, aes(x = index)) +
theme_classic() +
geom_ribbon(aes(ymin = lower, ymax = upper, fill = "indianred"), alpha = 0.5) + #credible intervals
geom_line(aes(y = predictions, colour = "red"), size = 0.25, alpha = .9) + #prediction point estimate
geom_point(aes(y = actual, colour = "black"), size = 0.55, shape = 16, alpha = 0.9) + #actual observation points
geom_line(aes(y = Ymean, colour = "blue"), size = 0.55, lty = "solid", alpha = 0.9) + #null model (mean only)
#ylab("Outage Duration (log hours)") +
ylab("Max Cust. Outages (log)") +
scale_y_continuous(labels = function(x) paste0(x)) +
xlab("Outage Index (event x county)") +
ggtitle(model_name) +
scale_fill_identity(name = "fill", guide = 'legend', labels = c('95% CI')) +
scale_colour_manual(name = 'colour',
values = c('black',"blue", "red"),
labels = c('Actual', 'Mean', 'BART'),
guide = guide_legend(
reverse = T,
override.aes = list(
linetype = c("solid", "solid","blank"),
shape = c(NA, NA, 16))
)) +
theme(plot.title = element_text(hjust = 0.5),
legend.title = element_blank(),
legend.direction = "vertical",
legend.box = "horizontal",
legend.position = c(.25, .75) #x and y percentage
) +
annotate("text", x = quantile(gg$index, 0.8), y = quantile(gg$actual, .05), label=lb1, parse=T, color="red", size = 3)
print(p)
}
plot_filtering_estimates2(gg)
# Feature selection (Kapelner and Bleich, 2016)
vs = var_selection_by_permute(bart, bottom_margin = 10, num_reps_for_avg = 20, num_permute_samples = 20, plot = F)
vs$important_vars_local_names
vs$important_vars_global_se_names
View(X)
# Feature selection (Kapelner and Bleich, 2016)
vs = var_selection_by_permute(bart, bottom_margin = 10, num_reps_for_avg = 20, num_permute_samples = 20, plot = T)
# Select only data we'll have available for prediction at the census tract level
county_outages_GROUP_CLEAN = county_outages_GROUP %>%
dplyr::select(-c(PS_mean:TQV_mean, AMBULANCES:DEATHS, EMPBLDG:HOSPBEDS, INTERNET:NURSHOMES, PHYSICIANS, PROFORGS:PROXCAP, RADIO:WATEFF, QEXTRCT, QNRRES)) %>%
dplyr::select(-c(RZ_mode, QGROUPHSE)) #take out variables where effect has high uncertaintly, likely from lingering multicollinearity
##############################################################################################################
#### MODELING ################################################################################################
##############################################################################################################
# Filter to large events (90th percentile in duration, > 12 hrs)
df_bart = data.frame(county_outages_GROUP_CLEAN) %>%
drop_na %>%
dplyr::filter(out_hrs > 12) #filter to big events
# y = log(df_bart$out_hrs) #take log to help deal with extreme values
y = log(df_bart$out_maxcust)
X = df_bart %>%
dplyr::select(-outage_number, -GEOID, -out_hrs, -out_maxcust, -out_percust)
model_name = paste("Predicting Max Outages - No Weather Data")
bart = bartMachine(X, y)
predictions = predict(bart, X)
CI = round(calc_credible_intervals(bart, X, ci_conf = 0.95), 2)
gg = dplyr::tibble(predictions = predictions,
lower = CI[,1],
upper = CI[,2],
actual = y
)
gg = arrange(gg, actual)
gg$index = seq.int(nrow(gg))
gg$Ymean = mean(gg$actual, na.rm = T)
rmse = sqrt(mean((gg$predictions - gg$actual)^2))
rsq = 1 - sum((gg$actual - gg$predictions)^2) / sum((gg$actual - mean(gg$actual))^2)
lb1 = paste("R^2 == ", round(rsq, 3))
plot_filtering_estimates2 <- function(df) {
p <- ggplot(data = gg, aes(x = index)) +
theme_classic() +
geom_ribbon(aes(ymin = lower, ymax = upper, fill = "indianred"), alpha = 0.5) + #credible intervals
geom_line(aes(y = predictions, colour = "red"), size = 0.25, alpha = .9) + #prediction point estimate
geom_point(aes(y = actual, colour = "black"), size = 0.55, shape = 16, alpha = 0.9) + #actual observation points
geom_line(aes(y = Ymean, colour = "blue"), size = 0.55, lty = "solid", alpha = 0.9) + #null model (mean only)
#ylab("Outage Duration (log hours)") +
ylab("Max Cust. Outages (log)") +
scale_y_continuous(labels = function(x) paste0(x)) +
xlab("Outage Index (event x county)") +
ggtitle(model_name) +
scale_fill_identity(name = "fill", guide = 'legend', labels = c('95% CI')) +
scale_colour_manual(name = 'colour',
values = c('black',"blue", "red"),
labels = c('Actual', 'Mean', 'BART'),
guide = guide_legend(
reverse = T,
override.aes = list(
linetype = c("solid", "solid","blank"),
shape = c(NA, NA, 16))
)) +
theme(plot.title = element_text(hjust = 0.5),
legend.title = element_blank(),
legend.direction = "vertical",
legend.box = "horizontal",
legend.position = c(.25, .75) #x and y percentage
) +
annotate("text", x = quantile(gg$index, 0.8), y = quantile(gg$actual, .05), label=lb1, parse=T, color="red", size = 3)
print(p)
}
plot_filtering_estimates2(gg)
# Feature selection (Kapelner and Bleich, 2016)
vs = var_selection_by_permute(bart, bottom_margin = 10, num_reps_for_avg = 20, num_permute_samples = 20, plot = T)
# Select only data we'll have available for prediction at the census tract level
county_outages_GROUP_CLEAN = county_outages_GROUP %>%
dplyr::select(-c(PS_mean:TQV_mean, AMBULANCES:DEATHS, EMPBLDG:HOSPBEDS, INTERNET:NURSHOMES, PHYSICIANS, PROFORGS:PROXCAP, RADIO:WATEFF, QEXTRCT, QNRRES)) %>%
dplyr::select(-c(RZ_mode, QGROUPHSE, QSERVIND)) #take out variables where effect has high uncertaintly, likely from lingering multicollinearity
##############################################################################################################
#### MODELING ################################################################################################
##############################################################################################################
# Filter to large events (90th percentile in duration, > 12 hrs)
df_bart = data.frame(county_outages_GROUP_CLEAN) %>%
drop_na %>%
dplyr::filter(out_hrs > 12) #filter to big events
# y = log(df_bart$out_hrs) #take log to help deal with extreme values
y = log(df_bart$out_maxcust)
X = df_bart %>%
dplyr::select(-outage_number, -GEOID, -out_hrs, -out_maxcust, -out_percust)
model_name = paste("Predicting Max Outages - No Weather Data")
bart = bartMachine(X, y)
predictions = predict(bart, X)
CI = round(calc_credible_intervals(bart, X, ci_conf = 0.95), 2)
gg = dplyr::tibble(predictions = predictions,
lower = CI[,1],
upper = CI[,2],
actual = y
)
gg = arrange(gg, actual)
gg$index = seq.int(nrow(gg))
gg$Ymean = mean(gg$actual, na.rm = T)
rmse = sqrt(mean((gg$predictions - gg$actual)^2))
rsq = 1 - sum((gg$actual - gg$predictions)^2) / sum((gg$actual - mean(gg$actual))^2)
lb1 = paste("R^2 == ", round(rsq, 3))
plot_filtering_estimates2 <- function(df) {
p <- ggplot(data = gg, aes(x = index)) +
theme_classic() +
geom_ribbon(aes(ymin = lower, ymax = upper, fill = "indianred"), alpha = 0.5) + #credible intervals
geom_line(aes(y = predictions, colour = "red"), size = 0.25, alpha = .9) + #prediction point estimate
geom_point(aes(y = actual, colour = "black"), size = 0.55, shape = 16, alpha = 0.9) + #actual observation points
geom_line(aes(y = Ymean, colour = "blue"), size = 0.55, lty = "solid", alpha = 0.9) + #null model (mean only)
#ylab("Outage Duration (log hours)") +
ylab("Max Cust. Outages (log)") +
scale_y_continuous(labels = function(x) paste0(x)) +
xlab("Outage Index (event x county)") +
ggtitle(model_name) +
scale_fill_identity(name = "fill", guide = 'legend', labels = c('95% CI')) +
scale_colour_manual(name = 'colour',
values = c('black',"blue", "red"),
labels = c('Actual', 'Mean', 'BART'),
guide = guide_legend(
reverse = T,
override.aes = list(
linetype = c("solid", "solid","blank"),
shape = c(NA, NA, 16))
)) +
theme(plot.title = element_text(hjust = 0.5),
legend.title = element_blank(),
legend.direction = "vertical",
legend.box = "horizontal",
legend.position = c(.25, .75) #x and y percentage
) +
annotate("text", x = quantile(gg$index, 0.8), y = quantile(gg$actual, .05), label=lb1, parse=T, color="red", size = 3)
print(p)
}
plot_filtering_estimates2(gg)
# Feature selection (Kapelner and Bleich, 2016)
vs = var_selection_by_permute(bart, bottom_margin = 10, num_reps_for_avg = 20, num_permute_samples = 20, plot = T)
vs$important_vars_local_names
vs$important_vars_global_se_names
# Select only data we'll have available for prediction at the census tract level
county_outages_GROUP_CLEAN = county_outages_GROUP %>%
dplyr::select(-c(PS_mean:TQV_mean, AMBULANCES:DEATHS, EMPBLDG:HOSPBEDS, INTERNET:NURSHOMES, PHYSICIANS, PROFORGS:PROXCAP, RADIO:WATEFF, QEXTRCT, QNRRES)) %>%
dplyr::select(-c(RZ_mode, QGROUPHSE, QSERVIND, QAGEWORK)) #take out variables where effect has high uncertaintly, likely from lingering multicollinearity
##############################################################################################################
#### MODELING ################################################################################################
##############################################################################################################
# Filter to large events (90th percentile in duration, > 12 hrs)
df_bart = data.frame(county_outages_GROUP_CLEAN) %>%
drop_na %>%
dplyr::filter(out_hrs > 12) #filter to big events
# y = log(df_bart$out_hrs) #take log to help deal with extreme values
y = log(df_bart$out_maxcust)
X = df_bart %>%
dplyr::select(-outage_number, -GEOID, -out_hrs, -out_maxcust, -out_percust)
model_name = paste("Predicting Max Outages - No Weather Data")
bart = bartMachine(X, y)
predictions = predict(bart, X)
CI = round(calc_credible_intervals(bart, X, ci_conf = 0.95), 2)
gg = dplyr::tibble(predictions = predictions,
lower = CI[,1],
upper = CI[,2],
actual = y
)
gg = arrange(gg, actual)
gg$index = seq.int(nrow(gg))
gg$Ymean = mean(gg$actual, na.rm = T)
rmse = sqrt(mean((gg$predictions - gg$actual)^2))
rsq = 1 - sum((gg$actual - gg$predictions)^2) / sum((gg$actual - mean(gg$actual))^2)
lb1 = paste("R^2 == ", round(rsq, 3))
plot_filtering_estimates2 <- function(df) {
p <- ggplot(data = gg, aes(x = index)) +
theme_classic() +
geom_ribbon(aes(ymin = lower, ymax = upper, fill = "indianred"), alpha = 0.5) + #credible intervals
geom_line(aes(y = predictions, colour = "red"), size = 0.25, alpha = .9) + #prediction point estimate
geom_point(aes(y = actual, colour = "black"), size = 0.55, shape = 16, alpha = 0.9) + #actual observation points
geom_line(aes(y = Ymean, colour = "blue"), size = 0.55, lty = "solid", alpha = 0.9) + #null model (mean only)
#ylab("Outage Duration (log hours)") +
ylab("Max Cust. Outages (log)") +
scale_y_continuous(labels = function(x) paste0(x)) +
xlab("Outage Index (event x county)") +
ggtitle(model_name) +
scale_fill_identity(name = "fill", guide = 'legend', labels = c('95% CI')) +
scale_colour_manual(name = 'colour',
values = c('black',"blue", "red"),
labels = c('Actual', 'Mean', 'BART'),
guide = guide_legend(
reverse = T,
override.aes = list(
linetype = c("solid", "solid","blank"),
shape = c(NA, NA, 16))
)) +
theme(plot.title = element_text(hjust = 0.5),
legend.title = element_blank(),
legend.direction = "vertical",
legend.box = "horizontal",
legend.position = c(.25, .75) #x and y percentage
) +
annotate("text", x = quantile(gg$index, 0.8), y = quantile(gg$actual, .05), label=lb1, parse=T, color="red", size = 3)
print(p)
}
plot_filtering_estimates2(gg)
# Feature selection (Kapelner and Bleich, 2016)
vs = var_selection_by_permute(bart, bottom_margin = 10, num_reps_for_avg = 20, num_permute_samples = 20, plot = T)
vs$important_vars_local_names
vs$important_vars_global_se_names
# Select only data we'll have available for prediction at the census tract level
county_outages_GROUP_CLEAN = county_outages_GROUP %>%
dplyr::select(-c(PS_mean:TQV_mean, AMBULANCES:DEATHS, EMPBLDG:HOSPBEDS, INTERNET:NURSHOMES, PHYSICIANS, PROFORGS:PROXCAP, RADIO:WATEFF, QEXTRCT, QNRRES)) %>%
dplyr::select(-c(RZ_mode, QGROUPHSE, QSERVIND, QAGEWORK, PATTACHRES)) #take out variables where effect has high uncertaintly, likely from lingering multicollinearity
##############################################################################################################
#### MODELING ################################################################################################
##############################################################################################################
# Filter to large events (90th percentile in duration, > 12 hrs)
df_bart = data.frame(county_outages_GROUP_CLEAN) %>%
drop_na %>%
dplyr::filter(out_hrs > 12) #filter to big events
# y = log(df_bart$out_hrs) #take log to help deal with extreme values
y = log(df_bart$out_maxcust)
X = df_bart %>%
dplyr::select(-outage_number, -GEOID, -out_hrs, -out_maxcust, -out_percust)
model_name = paste("Predicting Max Outages - No Weather Data")
bart = bartMachine(X, y)
predictions = predict(bart, X)
CI = round(calc_credible_intervals(bart, X, ci_conf = 0.95), 2)
gg = dplyr::tibble(predictions = predictions,
lower = CI[,1],
upper = CI[,2],
actual = y
)
gg = arrange(gg, actual)
gg$index = seq.int(nrow(gg))
gg$Ymean = mean(gg$actual, na.rm = T)
rmse = sqrt(mean((gg$predictions - gg$actual)^2))
rsq = 1 - sum((gg$actual - gg$predictions)^2) / sum((gg$actual - mean(gg$actual))^2)
lb1 = paste("R^2 == ", round(rsq, 3))
plot_filtering_estimates2 <- function(df) {
p <- ggplot(data = gg, aes(x = index)) +
theme_classic() +
geom_ribbon(aes(ymin = lower, ymax = upper, fill = "indianred"), alpha = 0.5) + #credible intervals
geom_line(aes(y = predictions, colour = "red"), size = 0.25, alpha = .9) + #prediction point estimate
geom_point(aes(y = actual, colour = "black"), size = 0.55, shape = 16, alpha = 0.9) + #actual observation points
geom_line(aes(y = Ymean, colour = "blue"), size = 0.55, lty = "solid", alpha = 0.9) + #null model (mean only)
#ylab("Outage Duration (log hours)") +
ylab("Max Cust. Outages (log)") +
scale_y_continuous(labels = function(x) paste0(x)) +
xlab("Outage Index (event x county)") +
ggtitle(model_name) +
scale_fill_identity(name = "fill", guide = 'legend', labels = c('95% CI')) +
scale_colour_manual(name = 'colour',
values = c('black',"blue", "red"),
labels = c('Actual', 'Mean', 'BART'),
guide = guide_legend(
reverse = T,
override.aes = list(
linetype = c("solid", "solid","blank"),
shape = c(NA, NA, 16))
)) +
theme(plot.title = element_text(hjust = 0.5),
legend.title = element_blank(),
legend.direction = "vertical",
legend.box = "horizontal",
legend.position = c(.25, .75) #x and y percentage
) +
annotate("text", x = quantile(gg$index, 0.8), y = quantile(gg$actual, .05), label=lb1, parse=T, color="red", size = 3)
print(p)
}
plot_filtering_estimates2(gg)
# Select only data we'll have available for prediction at the census tract level
county_outages_GROUP_CLEAN = county_outages_GROUP %>%
dplyr::select(-c(PS_mean:TQV_mean, AMBULANCES:DEATHS, EMPBLDG:HOSPBEDS, INTERNET:NURSHOMES, PHYSICIANS, PROFORGS:PROXCAP, RADIO:WATEFF, QEXTRCT, QNRRES)) %>%
dplyr::select(-c(RZ_mode, QGROUPHSE, QSERVIND)) #take out variables where effect has high uncertaintly, likely from lingering multicollinearity
##############################################################################################################
#### MODELING ################################################################################################
##############################################################################################################
# Filter to large events (90th percentile in duration, > 12 hrs)
df_bart = data.frame(county_outages_GROUP_CLEAN) %>%
drop_na %>%
dplyr::filter(out_hrs > 12) #filter to big events
# y = log(df_bart$out_hrs) #take log to help deal with extreme values
y = log(df_bart$out_maxcust)
X = df_bart %>%
dplyr::select(-outage_number, -GEOID, -out_hrs, -out_maxcust, -out_percust)
model_name = paste("Predicting Max Outages - No Weather Data")
bart = bartMachine(X, y)
predictions = predict(bart, X)
CI = round(calc_credible_intervals(bart, X, ci_conf = 0.95), 2)
gg = dplyr::tibble(predictions = predictions,
lower = CI[,1],
upper = CI[,2],
actual = y
)
gg = arrange(gg, actual)
gg$index = seq.int(nrow(gg))
gg$Ymean = mean(gg$actual, na.rm = T)
rmse = sqrt(mean((gg$predictions - gg$actual)^2))
rsq = 1 - sum((gg$actual - gg$predictions)^2) / sum((gg$actual - mean(gg$actual))^2)
lb1 = paste("R^2 == ", round(rsq, 3))
plot_filtering_estimates2 <- function(df) {
p <- ggplot(data = gg, aes(x = index)) +
theme_classic() +
geom_ribbon(aes(ymin = lower, ymax = upper, fill = "indianred"), alpha = 0.5) + #credible intervals
geom_line(aes(y = predictions, colour = "red"), size = 0.25, alpha = .9) + #prediction point estimate
geom_point(aes(y = actual, colour = "black"), size = 0.55, shape = 16, alpha = 0.9) + #actual observation points
geom_line(aes(y = Ymean, colour = "blue"), size = 0.55, lty = "solid", alpha = 0.9) + #null model (mean only)
#ylab("Outage Duration (log hours)") +
ylab("Max Cust. Outages (log)") +
scale_y_continuous(labels = function(x) paste0(x)) +
xlab("Outage Index (event x county)") +
ggtitle(model_name) +
scale_fill_identity(name = "fill", guide = 'legend', labels = c('95% CI')) +
scale_colour_manual(name = 'colour',
values = c('black',"blue", "red"),
labels = c('Actual', 'Mean', 'BART'),
guide = guide_legend(
reverse = T,
override.aes = list(
linetype = c("solid", "solid","blank"),
shape = c(NA, NA, 16))
)) +
theme(plot.title = element_text(hjust = 0.5),
legend.title = element_blank(),
legend.direction = "vertical",
legend.box = "horizontal",
legend.position = c(.25, .75) #x and y percentage
) +
annotate("text", x = quantile(gg$index, 0.8), y = quantile(gg$actual, .05), label=lb1, parse=T, color="red", size = 3)
print(p)
}
plot_filtering_estimates2(gg)
# Feature selection (Kapelner and Bleich, 2016)
vs = var_selection_by_permute(bart, bottom_margin = 10, num_reps_for_avg = 20, num_permute_samples = 20, plot = T)
vs$important_vars_local_names
vs$important_vars_global_se_names
View(df_bart)
#feature selection
X = df_bart %>%
dplyr::select(-outage_number, -GEOID, -out_hrs, -out_maxcust, -out_percust) %>%
dplyr::select(c("spi24_lag","Density", "Developed", "QMOHO", "QFEMALE", "QNATIVE", "RZ_mean"))
model_name = paste("Predicting Max Outages - No Weather Data")
model_name = paste("Predicting Max Outages - No Weather Data (Featured)")
model_name = paste("Predicting Max Outages - No Weather Data")
bart = bartMachine(X, y)
predictions = predict(bart, X)
CI = round(calc_credible_intervals(bart, X, ci_conf = 0.95), 2)
gg = dplyr::tibble(predictions = predictions,
lower = CI[,1],
upper = CI[,2],
actual = y
)
gg = arrange(gg, actual)
gg$index = seq.int(nrow(gg))
gg$Ymean = mean(gg$actual, na.rm = T)
rmse = sqrt(mean((gg$predictions - gg$actual)^2))
rsq = 1 - sum((gg$actual - gg$predictions)^2) / sum((gg$actual - mean(gg$actual))^2)
lb1 = paste("R^2 == ", round(rsq, 3))
plot_filtering_estimates2 <- function(df) {
p <- ggplot(data = gg, aes(x = index)) +
theme_classic() +
geom_ribbon(aes(ymin = lower, ymax = upper, fill = "indianred"), alpha = 0.5) + #credible intervals
geom_line(aes(y = predictions, colour = "red"), size = 0.25, alpha = .9) + #prediction point estimate
geom_point(aes(y = actual, colour = "black"), size = 0.55, shape = 16, alpha = 0.9) + #actual observation points
geom_line(aes(y = Ymean, colour = "blue"), size = 0.55, lty = "solid", alpha = 0.9) + #null model (mean only)
#ylab("Outage Duration (log hours)") +
ylab("Max Cust. Outages (log)") +
scale_y_continuous(labels = function(x) paste0(x)) +
xlab("Outage Index (event x county)") +
ggtitle(model_name) +
scale_fill_identity(name = "fill", guide = 'legend', labels = c('95% CI')) +
scale_colour_manual(name = 'colour',
values = c('black',"blue", "red"),
labels = c('Actual', 'Mean', 'BART'),
guide = guide_legend(
reverse = T,
override.aes = list(
linetype = c("solid", "solid","blank"),
shape = c(NA, NA, 16))
)) +
theme(plot.title = element_text(hjust = 0.5),
legend.title = element_blank(),
legend.direction = "vertical",
legend.box = "horizontal",
legend.position = c(.25, .75) #x and y percentage
) +
annotate("text", x = quantile(gg$index, 0.8), y = quantile(gg$actual, .05), label=lb1, parse=T, color="red", size = 3)
print(p)
}
plot_filtering_estimates2(gg)
plot_filtering_estimates2 <- function(df) {
p <- ggplot(data = gg, aes(x = index)) +
theme_classic() +
geom_ribbon(aes(ymin = lower, ymax = upper, fill = "indianred"), alpha = 0.5) + #credible intervals
geom_line(aes(y = predictions, colour = "red"), size = 0.25, alpha = .9) + #prediction point estimate
geom_point(aes(y = actual, colour = "black"), size = 0.55, shape = 16, alpha = 0.9) + #actual observation points
geom_line(aes(y = Ymean, colour = "blue"), size = 0.55, lty = "solid", alpha = 0.9) + #null model (mean only)
#ylab("Outage Duration (log hours)") +
ylab("Max Cust. Outages (log)") +
scale_y_continuous(labels = function(x) paste0(x)) +
xlab("Outage Index (event x county)") +
ggtitle(model_name) +
scale_fill_identity(name = "fill", guide = 'legend', labels = c('95% CI')) +
scale_colour_manual(name = 'colour',
values = c('black',"blue", "red"),
labels = c('Actual', 'Mean', 'BART'),
guide = guide_legend(
reverse = T,
override.aes = list(
linetype = c("solid", "solid","blank"),
shape = c(NA, NA, 16))
)) +
theme(plot.title = element_text(hjust = 0.5),
legend.title = element_blank(),
legend.direction = "vertical",
legend.box = "horizontal",
legend.position = c(.25, .75) #x and y percentage
) +
annotate("text", x = quantile(gg$index, 0.8), y = quantile(gg$actual, .05), label=lb1, parse=T, color="red", size = 3)
print(p)
}
plot_filtering_estimates2(gg)
