library(tidyverse) #collection of r data tools, including dplyr
library(mapview)
year=2018
### Geometry base - US Counties
options(tigris_use_cache = TRUE) #to cache shapefiles for future sessions
state = "Georgia"
county = c("Cherokee", "Cobb")
county_map = get_acs(geography = "tract", state = state, county = county,
variables=c("B01003_001"), year = year, geometry = TRUE,
cache_table = TRUE)
county_map = county_map %>% select(GEOID, NAME)
### Data from ACS-5yr
acs_vars_use = c("B01001B_001", "B01001A_001", "B01003_001")
acs_data = get_acs(geography = "tract", state = state, county = county,
variables=acs_vars_use, year = year, geometry = FALSE)
#long to wide format
acs_data_w = acs_data %>%
select(-moe, -NAME) %>% #remove errors of estimates because we're spreading by variable and don't want duplicates, and don't need name b/c joining by GEOID
spread(key=variable, value = estimate)
df = county_map %>%
left_join(acs_data_w, by = "GEOID") %>% #join ACS_5yr data
mutate(QBLACK = B01001B_001 / B01003_001) %>%
mutate(QWHITE = B01001A_001 / B01003_001) %>%
dplyr::select(QWHITE, QBLACK)
white = df %>%
ggplot(aes(fill = QWHITE)) +
geom_sf(color = NA) +
scale_fill_viridis_c(option = "magma")
mapview(df, zcol = c("QWHITE"), legend = TRUE, alpha.regions = 0.32)
mapview(df, zcol = c("QBLACK"), legend = TRUE, alpha.regions = 0.32)
### Subdivision
state = "Georgia"
county = c("Cherokee", "Cobb")
sub_map = get_acs(geography = "county subdivision", state = state, county = county,
variables=c("B01003_001"), year = year, geometry = TRUE,
cache_table = TRUE)
sub_map = sub_map %>% select(GEOID, NAME)
### Subdivision
sub_map = get_acs(geography = "county subdivision", state = state, county = county,
variables=c("B01003_001"), year = year, geometry = TRUE,
cache_table = TRUE)
sub_map = sub_map %>% select(GEOID, NAME)
acs_sub = get_acs(geography = "county subdivision", state = state, county = county,
variables=acs_vars_use, year = year, geometry = FALSE)
acs_sub_w = acs_sub %>%
select(-moe, -NAME) %>% #remove errors of estimates because we're spreading by variable and don't want duplicates, and don't need name b/c joining by GEOID
spread(key=variable, value = estimate)
df_sub = sub_map %>%
left_join(acs_data_w, by = "GEOID") %>% #join ACS_5yr data
mutate(QBLACK = B01001B_001 / B01003_001) %>%
mutate(QWHITE = B01001A_001 / B01003_001) %>%
dplyr::select(QWHITE, QBLACK)
mapview(df_sub, zcol = c("QBLACK"), legend = TRUE, alpha.regions = 0.32)
df_sub
acs_sub_w
sub_map
df_sub
View(df_sub)
### Subdivision
sub_map = get_acs(geography = "block group", state = state, county = county,
variables=c("B01003_001"), year = year, geometry = TRUE,
cache_table = TRUE)
sub_map = sub_map %>% select(GEOID, NAME)
acs_sub_w = acs_sub %>%
select(-moe, -NAME) %>% #remove errors of estimates because we're spreading by variable and don't want duplicates, and don't need name b/c joining by GEOID
spread(key=variable, value = estimate)
mapview(df_sub, zcol = c("QBLACK"), legend = TRUE, alpha.regions = 0.32)
acs_sub = get_acs(geography = "block group", state = state, county = county,
variables=acs_vars_use, year = year, geometry = FALSE)
df_sub = sub_map %>%
left_join(acs_data_w, by = "GEOID") %>% #join ACS_5yr data
mutate(QBLACK = B01001B_001 / B01003_001) %>%
mutate(QWHITE = B01001A_001 / B01003_001) %>%
dplyr::select(QWHITE, QBLACK)
df_sub
v18 = load_variables(2018, "acs5", cache = TRUE)
View(v18)
mapview(df, zcol = c("QBLACK"), legend = TRUE, alpha.regions = 0.32)
library(tidycensus) #api with census
library(sf) #class and functions for vector data
library(tidyverse) #collection of r data tools, including dplyr
library(mapview)
year=2018
state = "Alabama"
county = c("Madison")
county_map = county_map %>% select(GEOID, NAME)
acs_data = get_acs(geography = "tract", state = state, county = county,
variables=acs_vars_use, year = year, geometry = FALSE)
### Geometry base - US Counties
options(tigris_use_cache = TRUE) #to cache shapefiles for future sessions
county_map = get_acs(geography = "tract", state = state, county = county,
variables=c("B01003_001"), year = year, geometry = TRUE,
cache_table = TRUE)
### Data from ACS-5yr
acs_vars_use = c("B01001B_001", "B01001A_001", "B01003_001")
df = county_map %>%
left_join(acs_data_w, by = "GEOID") %>% #join ACS_5yr data
mutate(QBLACK = B01001B_001 / B01003_001) %>%
mutate(QWHITE = B01001A_001 / B01003_001) %>%
dplyr::select(QWHITE, QBLACK)
#long to wide format
acs_data_w = acs_data %>%
select(-moe, -NAME) %>% #remove errors of estimates because we're spreading by variable and don't want duplicates, and don't need name b/c joining by GEOID
spread(key=variable, value = estimate)
#long to wide format
acs_data_w = acs_data %>%
select(-moe, -NAME) %>% #remove errors of estimates because we're spreading by variable and don't want duplicates, and don't need name b/c joining by GEOID
spread(key=variable, value = estimate)
acs_data = get_acs(geography = "tract", state = state, county = county,
variables=acs_vars_use, year = year, geometry = FALSE)
#long to wide format
acs_data_w = acs_data %>%
select(-moe, -NAME) %>% #remove errors of estimates because we're spreading by variable and don't want duplicates, and don't need name b/c joining by GEOID
spread(key=variable, value = estimate)
df = county_map %>%
left_join(acs_data_w, by = "GEOID") %>% #join ACS_5yr data
mutate(QBLACK = B01001B_001 / B01003_001) %>%
mutate(QWHITE = B01001A_001 / B01003_001) %>%
dplyr::select(QWHITE, QBLACK)
mapview(df, zcol = c("QBLACK"), legend = TRUE, alpha.regions = 0.32)
# LIST OF VARIABLES
v18 = load_variables(2018, "acs5", cache = TRUE)
View(v18)
library(tidyverse)
library(readxl)
library(sf)
library(tidycensus)
library(tidycensus) #api with census
library(sf) #class and functions for vector data
library(tidyverse) #collection of r data tools, including dplyr
library(mapview)
year=2018
### Geometry base - US Counties
options(tigris_use_cache = TRUE) #to cache shapefiles for future sessions
state = "Texas"
county = c("Harris")
county_map = get_acs(geography = "tract", state = state, county = county,
variables=c("B01003_001"), year = year, geometry = TRUE,
cache_table = TRUE)
county = c("Harris County")
county_map = get_acs(geography = "tract", state = state, county = county,
variables=c("B01003_001"), year = year, geometry = TRUE,
cache_table = TRUE)
View(county_map)
county_map = county_map %>% select(GEOID, NAME)
### Data from ACS-5yr
acs_vars_use = c("B01001B_001", "B01001A_001", "B01003_001")
acs_data = get_acs(geography = "tract", state = state, county = county,
variables=acs_vars_use, year = year, geometry = FALSE)
#long to wide format
acs_data_w = acs_data %>%
select(-moe, -NAME) %>% #remove errors of estimates because we're spreading by variable and don't want duplicates, and don't need name b/c joining by GEOID
spread(key=variable, value = estimate)
df = county_map %>%
left_join(acs_data_w, by = "GEOID") %>% #join ACS_5yr data
mutate(QBLACK = B01001B_001 / B01003_001) %>%
mutate(QWHITE = B01001A_001 / B01003_001) %>%
dplyr::select(QWHITE, QBLACK)
white = df %>%
ggplot(aes(fill = QWHITE)) +
geom_sf(color = NA) +
scale_fill_viridis_c(option = "magma")
plot(white)
View(county_map)
write.csv(county_map, "/Users/paulmj/Documents/01_VECTOR/UH_CIVIC/Harris_census_2018.csv", row.names = TRUE)
county_map2 = county_map %>%
st_geometry(NULL)
county_map2 = county_map %>%
st_set_geometry(NULL)
write.csv(county_map2, "/Users/paulmj/Documents/01_VECTOR/UH_CIVIC/Harris_census_2018.csv", row.names = TRUE)
year=2019
### Geometry base - US Counties
options(tigris_use_cache = TRUE) #to cache shapefiles for future sessions
state = "Texas"
county = c("Harris County")
county_map = get_acs(geography = "tract", state = state, county = county,
variables=c("B01003_001"), year = year, geometry = TRUE,
cache_table = TRUE)
county_map = county_map %>% select(GEOID, NAME)
### Data from ACS-5yr
acs_vars_use = c("B01001B_001", "B01001A_001", "B01003_001")
acs_data = get_acs(geography = "tract", state = state, county = county,
variables=acs_vars_use, year = year, geometry = FALSE)
#long to wide format
acs_data_w = acs_data %>%
select(-moe, -NAME) %>% #remove errors of estimates because we're spreading by variable and don't want duplicates, and don't need name b/c joining by GEOID
spread(key=variable, value = estimate)
df = county_map %>%
left_join(acs_data_w, by = "GEOID") %>% #join ACS_5yr data
mutate(QBLACK = B01001B_001 / B01003_001) %>%
mutate(QWHITE = B01001A_001 / B01003_001) %>%
dplyr::select(QWHITE, QBLACK)
white = df %>%
ggplot(aes(fill = QWHITE)) +
geom_sf(color = NA) +
scale_fill_viridis_c(option = "magma")
black = df %>%
ggplot(aes(fill = QBLACK)) +
geom_sf(color = NA) +
scale_fill_viridis_c(option = "magma")
county_map2 = county_map %>%
st_set_geometry(NULL)
write.csv(county_map2, "/Users/paulmj/Documents/01_VECTOR/UH_CIVIC/Harris_censustract_2019acs.csv", row.names = TRUE)
year=2020
### Geometry base - US Counties
options(tigris_use_cache = TRUE) #to cache shapefiles for future sessions
state = "Texas"
county = c("Harris County")
county_map = get_acs(geography = "tract", state = state, county = county,
variables=c("B01003_001"), year = year, geometry = TRUE,
cache_table = TRUE)
?get_acs
county_map = get_acs(geography = "tract", state = state, county = county,
variables=c("B01003_001"), year = 2020, geometry = TRUE,
cache_table = TRUE, survey = "acs1")
county_map = get_acs(geography = "tract", state = state, county = county,
variables=c("B01003_001"), year = 2019, geometry = TRUE,
cache_table = TRUE, survey = "acs1")
county_map = get_acs(geography = "tract", state = state, county = county,
variables=c("B01003_001"), year = 2019, geometry = TRUE,
cache_table = TRUE, survey = "acs5")
county_map = get_acs(geography = "tract", state = state, county = county,
variables=c("B01003_001"), year = 2019, geometry = TRUE,
cache_table = TRUE, survey = "acs1")
county_map = get_acs(geography = "tract", state = state, county = county,
variables=c("B01003_001"), year = 2020, geometry = TRUE,
cache_table = TRUE, survey = "acs1")
county_map = get_acs(geography = "tract", state = state, county = county,
variables=c("B01003_001"), year = 2021, geometry = TRUE,
cache_table = TRUE, survey = "acs1")
county_map = get_acs(geography = "tract", state = state, county = county,
variables=c("B01003_001"), year = 2019, geometry = TRUE,
cache_table = TRUE, survey = "acs1")
county_map = county_map %>% select(GEOID, NAME)
install.packages("stars")
library(tidyverse)
library(tidycensus)
library(sf)
library(terra)
library(stars)
load("~/Documents/01_VECTOR.nosync/Sandia/TX_group.Rda")
## Root zone data
TX_gdb =  "/Users/paulmj/Downloads/gSSURGO_TX/gSSURGO_TX.gdb"
TX_Valu1 = sf::st_read(dsn = TX_gdb, layer = "Valu1")
TX_group_val1 = TX_group %>% left_join(TX_Valu1, by = c("MUKEY" = "mukey"))
TX_group_val1_100 = TX_group_val1 %>%
filter(!is.na(rootznemc)) %>%
slice(1:100) %>%
select(MUKEY, rootznemc)
?st_rasterize
TX_rast100 = st_rasterize(TX_group_val1_100)
TX_rast100 = st_rasterize(TX_group_val1_100["rootznemc"])
plot(TX_rast100)
TX_rast = st_rasterize(TX_group_val1["rootznemc"])
plot(TX_rast)
rr = ggplot() +
geom_tile(data = TX_rast, aes(x = x, y = y, fill = rootznemc)) +
scale_fill_viridis_c()
rr = ggplot() +
geom_stars(data = TX_rast, aes(x = x, y = y, fill = rootznemc)) +
scale_fill_viridis_c()
rr
rr = ggplot() +
geom_stars(data = TX_rast, aes(x = x, y = y, fill = rootznemc)) +
scale_fill_viridis_c(direction = -1)
rr
rr = ggplot() +
#geom_stars(data = TX_rast, aes(x = x, y = y, fill = rootznemc)) +
geom_stars(data = TX_rast, aes(fill = rootznemc)) +
scale_fill_viridis_c(direction = -1)
rr
rr = ggplot() +
geom_stars(data = TX_rast, aes(x = x, y = y, fill = rootznemc)) +
scale_fill_viridis_c(direction = -1)
rr
rr = ggplot() +
geom_stars(data = TX_rast, aes(x = x, y = y, fill = rootznemc), alpha = 0.8) +
scale_fill_viridis_c(direction = -1)
rr
rr = ggplot() +
geom_stars(data = TX_rast, aes(x = x, y = y, fill = rootznemc), alpha = 0.9) +
scale_fill_viridis_c(direction = -1)
rr
rr = ggplot() +
geom_stars(data = TX_rast, aes(x = x, y = y, fill = rootznemc)) +
scale_fill_viridis_c(direction = -1)
rr
rr = ggplot() +
geom_stars(data = TX_rast, aes(x = x, y = y, fill = rootznemc)) +
scale_fill_viridis_c(direction = -1) +
theme_bw()
rr
rr = ggplot() +
geom_stars(data = TX_rast, aes(x = x, y = y, fill = rootznemc)) +
scale_fill_viridis_c(direction = -1) +
theme_classic()
rr
rr = ggplot() +
geom_stars(data = TX_rast, aes(x = x, y = y, fill = rootznemc)) +
scale_fill_viridis_c(direction = -1) +
theme_minimal()
rr
rr = ggplot() +
geom_stars(data = TX_rast, aes(x = x, y = y, fill = rootznemc)) +
scale_fill_viridis_c(direction = -1)
rr
rr = ggplot() +
geom_stars(data = TX_rast, aes(x = x, y = y, fill = rootznemc)) +
scale_fill_viridis_c(direction = -1, na.value = "white")
rr
rr = ggplot() +
geom_stars(data = TX_rast, aes(x = x, y = y, fill = rootznemc)) +
scale_fill_viridis_c(direction = -1, na.value = "gray")
rr
rr = ggplot() +
geom_stars(data = TX_rast, aes(x = x, y = y, fill = rootznemc)) +
scale_fill_viridis_c(direction = -1, na.value = "gray") +
theme_light()
rr
rr = ggplot() +
geom_stars(data = TX_rast, aes(x = x, y = y, fill = rootznemc)) +
scale_fill_viridis_c(direction = -1, na.value = "gray") +
theme_minimal()
rr
st_crs(TX_rast)
st_crs(TX_rast)$units_gdal
TX_rast_1k = st_rasterize(TX_group_val1["rootznemc"], dx = 1000, dy = 1000)
rr = ggplot() +
geom_stars(data = TX_rast_1k, aes(x = x, y = y, fill = rootznemc)) +
scale_fill_viridis_c(direction = -1, na.value = "gray") +
theme_minimal()
rr
library(tidyverse)
library(tidycensus)
library(sf)
library(terra)
library(stars)
setwd("~/Documents/01_VECTOR.nosync/Sandia")
mycrs = 5070
##### CONTIGUOUS US COUNTY MAP ######################################################
year=2019
options(tigris_use_cache = TRUE) #to cache shapefiles for future sessions
state_list = c("AL", "AR", "AZ", "CA", "CO", "CT", "DE", "FL", "GA", "IA", "ID", "IL", "IN", "KS", "KY", "LA", "MA", "MD", "ME", "MI", "MN", "MO", "MS", "MT", "NC", "ND", "NE", "NH", "NJ", "NM", "NV", "NY", "OH", "OK", "OR", "PA", "RI", "SC", "SD", "TN", "TX", "UT", "VA", "VT", "WA", "WI", "WV", "WY")
county_map = get_acs(geography = "county", state = state_list,
variables=c("B01003_001"), year = year, geometry = TRUE,
cache_table = TRUE)
## Project county map and calculate area and population density of each county
county_map_proj = county_map %>%
st_transform(mycrs) # project to Conic Equal Area Albers, EPSG:5070
county_map = county_map %>%
mutate(POPULATION = estimate) %>%
dplyr::select(GEOID, NAME, POPULATION)
county_map_area = county_map_proj %>%
mutate(AREA = as.vector(st_area(county_map_proj))) %>% ## calculate area of each county (sq-meters); as.vector removes units suffix
mutate(DENSITY = POPULATION / AREA * 1000^2) #population per sq-km
## Project county map and calculate area and population density of each county
county_map_proj = county_map %>%
st_transform(mycrs) # project to Conic Equal Area Albers, EPSG:5070
county_map_area = county_map_proj %>%
mutate(AREA = as.vector(st_area(county_map_proj))) %>% ## calculate area of each county (sq-meters); as.vector removes units suffix
mutate(DENSITY = POPULATION / AREA * 1000^2) #population per sq-km
## Get list of .grb files
grb.names = list.files(path = "/Users/paulmj/Downloads/NLDAS_NOAH_2018_hourly_grb", full.names = T,
pattern = "\\.grb$") # get file names and restrict pattern to ending in .grb
i = 1
temp_i = grb.names[i]
print(temp_i)
# Read in data
#temp_stars = read_stars(temp_i) #read in file as stars class
temp_rast = rast(temp_i) #read in as raster layers
# Project, crop, and mask rasters
temp_proj = terra::project(temp_rast, paste("EPSG:", mycrs)) #transform raster into my CRS
temp_crop = terra::crop(temp_proj, vect(county_map_proj)) #crop to map
temp_mask = terra::mask(temp_crop, vect(county_map_proj)) #mask to map (make anything outside NA)
# Get soil moisture layers (3 of them)
temp_s26 = temp_mask[[26]] # soil moisture 0-10cm (kg/m^2)
temp_s27 = temp_mask[[27]] # soil moisture 10-40cm (kg/m^2)
temp_s28 = temp_mask[[28]] # soil moisture 40-100cm (kg/m^2)
# Extract soil layer values by county
temp_extract26 = terra::extract(x = temp_s26, y = vect(county_map_proj)) %>%
group_by(ID) %>%
summarise(across(everything(), mean, na.rm = TRUE))
temp_extract27 = terra::extract(x = temp_s27, y = vect(county_map_proj)) %>%
group_by(ID) %>%
summarise(across(everything(), mean, na.rm = TRUE))
temp_extract28 = terra::extract(x = temp_s28, y = vect(county_map_proj)) %>%
group_by(ID) %>%
summarise(across(everything(), mean, na.rm = TRUE))
# Join temp extractions by ID
temp_extract = temp_extract26 %>%
inner_join(temp_extract27, by = c("ID")) %>%
inner_join(temp_extract28, by = c("ID"))
colnames(temp_extract) = c("ID", "soil0_10", "soil10_40", "soil40_100")
# Add date_hour (character) variable whose value is the file name, formatted to match outage data ("2018-01-01T00:00:00Z")
temp_name1 = sub(".002.grb", "", sub(".*NLDAS_NOAH0125_H.A", "", temp_i)) #"YYYYMMDD.HHMM"
temp_name2 = paste(substr(temp_name1, 1, 4), "-", substr(temp_name1, 5, 6), "-", substr(temp_name1, 7, 8), "T", substr(temp_name1, 10, 11), ":", substr(temp_name1, 12, 13), ":00Z", sep = "")
substr(temp_name2, 1,10)
temp_day = substr(temp_name2, 1,10)
temp_out = temp_extract
temp_out$date_hour = temp_name2
temp_out$date_day = temp_day
View(temp_out)
# Data-frame of GEOID, date-time (hourly), and 3 soil moisture layer variables
temp_map_soil = county_map_proj %>%
bind_cols(temp_out) %>%
dplyr::select(-ID, -POPULATION)
# Data-frame of GEOID, date-time (hourly), and 3 soil moisture layer variables
temp_map_soil = county_map_proj %>%
bind_cols(temp_out) %>%
dplyr::select(-ID, -POPULATION) %>%
st_set_geometry(NULL)
setwd("~/Documents/01_VECTOR.nosync/Sandia")
mycrs = 5070
##### CONTIGUOUS US COUNTY MAP ######################################################
year=2019
options(tigris_use_cache = TRUE) #to cache shapefiles for future sessions
state_list = c("AL", "AR", "AZ", "CA", "CO", "CT", "DE", "FL", "GA", "IA", "ID", "IL", "IN", "KS", "KY", "LA", "MA", "MD", "ME", "MI", "MN", "MO", "MS", "MT", "NC", "ND", "NE", "NH", "NJ", "NM", "NV", "NY", "OH", "OK", "OR", "PA", "RI", "SC", "SD", "TN", "TX", "UT", "VA", "VT", "WA", "WI", "WV", "WY")
county_map = get_acs(geography = "county", state = state_list,
variables=c("B01003_001"), year = year, geometry = TRUE,
cache_table = TRUE)
## Project county map and calculate area and population density of each county
county_map_proj = county_map %>%
st_transform(mycrs) # project to Conic Equal Area Albers, EPSG:5070
county_map = county_map %>%
mutate(POPULATION = estimate) %>%
dplyr::select(GEOID, NAME, POPULATION)
county_map_area = county_map_proj %>%
mutate(AREA = as.vector(st_area(county_map_proj))) %>% ## calculate area of each county (sq-meters); as.vector removes units suffix
mutate(DENSITY = POPULATION / AREA * 1000^2) #population per sq-km
county_map_area = county_map_proj %>%
mutate(AREA = as.vector(st_area(county_map_proj))) %>% ## calculate area of each county (sq-meters); as.vector removes units suffix
mutate(DENSITY = POPULATION / AREA * 1000^2) #population per sq-km
county_map = county_map %>%
mutate(POPULATION = estimate) %>%
dplyr::select(GEOID, NAME, POPULATION)
county_map = get_acs(geography = "county", state = state_list,
variables=c("B01003_001"), year = year, geometry = TRUE,
cache_table = TRUE)
county_map = county_map %>%
mutate(POPULATION = estimate) %>%
dplyr::select(GEOID, NAME, POPULATION)
## Project county map and calculate area and population density of each county
county_map_proj = county_map %>%
st_transform(mycrs) # project to Conic Equal Area Albers, EPSG:5070
county_map_area = county_map_proj %>%
mutate(AREA = as.vector(st_area(county_map_proj))) %>% ## calculate area of each county (sq-meters); as.vector removes units suffix
mutate(DENSITY = POPULATION / AREA * 1000^2) #population per sq-km
## Get list of .grb files
grb.names = list.files(path = "/Users/paulmj/Downloads/NLDAS_NOAH_2018_hourly_grb", full.names = T,
pattern = "\\.grb$") # get file names and restrict pattern to ending in .grb
## Iterate through .grb files (takes less memory) length(grb.names)
for (i in 1:48){
temp_i = grb.names[i]
print(temp_i)
# Read in data
#temp_stars = read_stars(temp_i) #read in file as stars class
temp_rast = rast(temp_i) #read in as raster layers
# Project, crop, and mask rasters
temp_proj = terra::project(temp_rast, paste("EPSG:", mycrs)) #transform raster into my CRS
temp_crop = terra::crop(temp_proj, vect(county_map_proj)) #crop to map
temp_mask = terra::mask(temp_crop, vect(county_map_proj)) #mask to map (make anything outside NA)
# Get soil moisture layers (3 of them)
temp_s26 = temp_mask[[26]] # soil moisture 0-10cm (kg/m^2)
temp_s27 = temp_mask[[27]] # soil moisture 10-40cm (kg/m^2)
temp_s28 = temp_mask[[28]] # soil moisture 40-100cm (kg/m^2)
# Extract soil layer values by county
temp_extract26 = terra::extract(x = temp_s26, y = vect(county_map_proj)) %>%
group_by(ID) %>%
summarise(across(everything(), mean, na.rm = TRUE))
temp_extract27 = terra::extract(x = temp_s27, y = vect(county_map_proj)) %>%
group_by(ID) %>%
summarise(across(everything(), mean, na.rm = TRUE))
temp_extract28 = terra::extract(x = temp_s28, y = vect(county_map_proj)) %>%
group_by(ID) %>%
summarise(across(everything(), mean, na.rm = TRUE))
# Join temp extractions by ID
temp_extract = temp_extract26 %>%
inner_join(temp_extract27, by = c("ID")) %>%
inner_join(temp_extract28, by = c("ID"))
colnames(temp_extract) = c("ID", "soil0_10", "soil10_40", "soil40_100")
# Add date_hour (character) variable whose value is the file name, formatted to match outage data ("2018-01-01T00:00:00Z")
temp_name1 = sub(".002.grb", "", sub(".*NLDAS_NOAH0125_H.A", "", temp_i)) #"YYYYMMDD.HHMM"
temp_name2 = paste(substr(temp_name1, 1, 4), "-", substr(temp_name1, 5, 6), "-", substr(temp_name1, 7, 8), "T", substr(temp_name1, 10, 11), ":", substr(temp_name1, 12, 13), ":00Z", sep = "")
temp_day = substr(temp_name2, 1,10)
temp_out = temp_extract
temp_out$date_hour = temp_name2
temp_out$date_day = temp_day
# Data-frame of GEOID, date-time (hourly and daily), and 3 soil moisture layer variables
temp_map_soil = county_map_proj %>%
bind_cols(temp_out) %>%
dplyr::select(-ID, -POPULATION) %>%
st_set_geometry(NULL)
# Use first dataset as output and row bind subsequent datasets to it
if (i == 1) {
county_map_soil = temp_map_soil
}
else {
county_map_soil = county_map_soil %>%
bind_rows(temp_map_soil)
}
# Save county_map_soil data around every month
if (i %in% 720*1:12) {
save(county_map_soil, file = "./Data/county_map_soil.Rda")
}
}
c(744, 672, 744, 720, 744, 720, 744, 744, 720, 744, 720, 744)
sum(c(744, 672, 744, 720, 744, 720, 744, 744, 720, 744, 720, 744))
cumsum(c(744, 672, 744, 720, 744, 720, 744, 744, 720, 744, 720, 744))
paste(asd,f, sep = "") = 32
paste("asd","f", sep = "") = 32
cumsum(c(744, 672, 744, 720, 744, 720, 744, 744, 720, 744, 720, 744))
View(county_map_soil)
